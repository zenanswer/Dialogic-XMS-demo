#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Nov 29 20:53:43 2017 by generateDS.py version 2.28.2.
# Python 2.7.14 (default, Sep 25 2017, 09:54:19)  [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.37)]
#
# Command line options:
#   ('-o', 'xmsrest.py')
#
# Command line arguments:
#   xmsrest.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py -o "xmsrest.py" xmsrest.xsd
#
# Current working directory (os.getcwd()):
#   xmsrestful
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class dvr_setting(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, forward_key='1', backward_key='2', pause_key='3', resume_key='4', restart_key='5'):
        self.original_tagname_ = None
        self.forward_key = _cast(None, forward_key)
        self.backward_key = _cast(None, backward_key)
        self.pause_key = _cast(None, pause_key)
        self.resume_key = _cast(None, resume_key)
        self.restart_key = _cast(None, restart_key)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dvr_setting)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dvr_setting.subclass:
            return dvr_setting.subclass(*args_, **kwargs_)
        else:
            return dvr_setting(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_forward_key(self): return self.forward_key
    def set_forward_key(self, forward_key): self.forward_key = forward_key
    def get_backward_key(self): return self.backward_key
    def set_backward_key(self, backward_key): self.backward_key = backward_key
    def get_pause_key(self): return self.pause_key
    def set_pause_key(self, pause_key): self.pause_key = pause_key
    def get_resume_key(self): return self.resume_key
    def set_resume_key(self, resume_key): self.resume_key = resume_key
    def get_restart_key(self): return self.restart_key
    def set_restart_key(self, restart_key): self.restart_key = restart_key
    def validate_digit_value(self, value):
        # Validate type digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_digit_value_patterns_, ))
    validate_digit_value_patterns_ = [['^[0-9#*]+$|^$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dvr_setting', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dvr_setting')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dvr_setting')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dvr_setting', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dvr_setting'):
        if self.forward_key != "1" and 'forward_key' not in already_processed:
            already_processed.add('forward_key')
            outfile.write(' forward_key=%s' % (quote_attrib(self.forward_key), ))
        if self.backward_key != "2" and 'backward_key' not in already_processed:
            already_processed.add('backward_key')
            outfile.write(' backward_key=%s' % (quote_attrib(self.backward_key), ))
        if self.pause_key != "3" and 'pause_key' not in already_processed:
            already_processed.add('pause_key')
            outfile.write(' pause_key=%s' % (quote_attrib(self.pause_key), ))
        if self.resume_key != "4" and 'resume_key' not in already_processed:
            already_processed.add('resume_key')
            outfile.write(' resume_key=%s' % (quote_attrib(self.resume_key), ))
        if self.restart_key != "5" and 'restart_key' not in already_processed:
            already_processed.add('restart_key')
            outfile.write(' restart_key=%s' % (quote_attrib(self.restart_key), ))
    def exportChildren(self, outfile, level, namespace_='', name_='dvr_setting', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('forward_key', node)
        if value is not None and 'forward_key' not in already_processed:
            already_processed.add('forward_key')
            self.forward_key = value
            self.validate_digit_value(self.forward_key)    # validate type digit_value
        value = find_attr_value_('backward_key', node)
        if value is not None and 'backward_key' not in already_processed:
            already_processed.add('backward_key')
            self.backward_key = value
            self.validate_digit_value(self.backward_key)    # validate type digit_value
        value = find_attr_value_('pause_key', node)
        if value is not None and 'pause_key' not in already_processed:
            already_processed.add('pause_key')
            self.pause_key = value
            self.validate_digit_value(self.pause_key)    # validate type digit_value
        value = find_attr_value_('resume_key', node)
        if value is not None and 'resume_key' not in already_processed:
            already_processed.add('resume_key')
            self.resume_key = value
            self.validate_digit_value(self.resume_key)    # validate type digit_value
        value = find_attr_value_('restart_key', node)
        if value is not None and 'restart_key' not in already_processed:
            already_processed.add('restart_key')
            self.restart_key = value
            self.validate_digit_value(self.restart_key)    # validate type digit_value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dvr_setting


class recording_audio_mime_params(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codec=None, mode=None, rate=None, bitrate=None, dtx=None):
        self.original_tagname_ = None
        self.codec = _cast(None, codec)
        self.mode = _cast(None, mode)
        self.rate = _cast(None, rate)
        self.bitrate = _cast(None, bitrate)
        self.dtx = _cast(None, dtx)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recording_audio_mime_params)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recording_audio_mime_params.subclass:
            return recording_audio_mime_params.subclass(*args_, **kwargs_)
        else:
            return recording_audio_mime_params(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codec(self): return self.codec
    def set_codec(self, codec): self.codec = codec
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def get_bitrate(self): return self.bitrate
    def set_bitrate(self, bitrate): self.bitrate = bitrate
    def get_dtx(self): return self.dtx
    def set_dtx(self, dtx): self.dtx = dtx
    def validate_audio_codec_option(self, value):
        # Validate type audio_codec_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['L8', 'L16', 'mulaw', 'alaw', 'AMR', 'AMR-WB', 'OPUS', 'native', 'EVS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on audio_codec_option' % {"value" : value.encode("utf-8")} )
    def validate_audio_codec_amr_mode_value(self, value):
        # Validate type audio_codec_amr_mode_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_audio_codec_amr_mode_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_audio_codec_amr_mode_value_patterns_, ))
    validate_audio_codec_amr_mode_value_patterns_ = [['^[0-8]$']]
    def validate_audio_rate_option(self, value):
        # Validate type audio_rate_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['8000', '11025', '16000']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on audio_rate_option' % {"value" : value.encode("utf-8")} )
    def validate_integer_value(self, value):
        # Validate type integer_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_integer_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_integer_value_patterns_, ))
    validate_integer_value_patterns_ = [['^[0-9]+$|^infinite$']]
    def validate_dtx_option(self, value):
        # Validate type dtx_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on dtx_option' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recording_audio_mime_params', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('recording_audio_mime_params')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recording_audio_mime_params')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recording_audio_mime_params', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recording_audio_mime_params'):
        if self.codec is not None and 'codec' not in already_processed:
            already_processed.add('codec')
            outfile.write(' codec=%s' % (quote_attrib(self.codec), ))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (quote_attrib(self.mode), ))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            outfile.write(' rate=%s' % (quote_attrib(self.rate), ))
        if self.bitrate is not None and 'bitrate' not in already_processed:
            already_processed.add('bitrate')
            outfile.write(' bitrate=%s' % (quote_attrib(self.bitrate), ))
        if self.dtx is not None and 'dtx' not in already_processed:
            already_processed.add('dtx')
            outfile.write(' dtx=%s' % (quote_attrib(self.dtx), ))
    def exportChildren(self, outfile, level, namespace_='', name_='recording_audio_mime_params', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codec', node)
        if value is not None and 'codec' not in already_processed:
            already_processed.add('codec')
            self.codec = value
            self.validate_audio_codec_option(self.codec)    # validate type audio_codec_option
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
            self.validate_audio_codec_amr_mode_value(self.mode)    # validate type audio_codec_amr_mode_value
        value = find_attr_value_('rate', node)
        if value is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            self.rate = value
            self.validate_audio_rate_option(self.rate)    # validate type audio_rate_option
        value = find_attr_value_('bitrate', node)
        if value is not None and 'bitrate' not in already_processed:
            already_processed.add('bitrate')
            self.bitrate = value
            self.validate_integer_value(self.bitrate)    # validate type integer_value
        value = find_attr_value_('dtx', node)
        if value is not None and 'dtx' not in already_processed:
            already_processed.add('dtx')
            self.dtx = value
            self.validate_dtx_option(self.dtx)    # validate type dtx_option
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class recording_audio_mime_params


class recording_video_mime_params(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codec=None, profile=None, level=None, framerate=None, maxbitrate=None, height=None, width=None):
        self.original_tagname_ = None
        self.codec = _cast(None, codec)
        self.profile = _cast(None, profile)
        self.level = _cast(None, level)
        self.framerate = _cast(None, framerate)
        self.maxbitrate = _cast(None, maxbitrate)
        self.height = _cast(None, height)
        self.width = _cast(None, width)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recording_video_mime_params)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recording_video_mime_params.subclass:
            return recording_video_mime_params.subclass(*args_, **kwargs_)
        else:
            return recording_video_mime_params(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codec(self): return self.codec
    def set_codec(self, codec): self.codec = codec
    def get_profile(self): return self.profile
    def set_profile(self, profile): self.profile = profile
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_framerate(self): return self.framerate
    def set_framerate(self, framerate): self.framerate = framerate
    def get_maxbitrate(self): return self.maxbitrate
    def set_maxbitrate(self, maxbitrate): self.maxbitrate = maxbitrate
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def validate_video_codec_option(self, value):
        # Validate type video_codec_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['h264', 'h263', 'h263-1998', 'mp4v-es', 'jpeg', 'vp8', 'vp9', 'native']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on video_codec_option' % {"value" : value.encode("utf-8")} )
    def validate_digit_value(self, value):
        # Validate type digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_digit_value_patterns_, ))
    validate_digit_value_patterns_ = [['^[0-9#*]+$|^$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recording_video_mime_params', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('recording_video_mime_params')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recording_video_mime_params')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recording_video_mime_params', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recording_video_mime_params'):
        if self.codec is not None and 'codec' not in already_processed:
            already_processed.add('codec')
            outfile.write(' codec=%s' % (quote_attrib(self.codec), ))
        if self.profile is not None and 'profile' not in already_processed:
            already_processed.add('profile')
            outfile.write(' profile=%s' % (quote_attrib(self.profile), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.level), input_name='level')), ))
        if self.framerate is not None and 'framerate' not in already_processed:
            already_processed.add('framerate')
            outfile.write(' framerate=%s' % (quote_attrib(self.framerate), ))
        if self.maxbitrate is not None and 'maxbitrate' not in already_processed:
            already_processed.add('maxbitrate')
            outfile.write(' maxbitrate=%s' % (quote_attrib(self.maxbitrate), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height=%s' % (quote_attrib(self.height), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (quote_attrib(self.width), ))
    def exportChildren(self, outfile, level, namespace_='', name_='recording_video_mime_params', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codec', node)
        if value is not None and 'codec' not in already_processed:
            already_processed.add('codec')
            self.codec = value
            self.validate_video_codec_option(self.codec)    # validate type video_codec_option
        value = find_attr_value_('profile', node)
        if value is not None and 'profile' not in already_processed:
            already_processed.add('profile')
            self.profile = value
            self.validate_digit_value(self.profile)    # validate type digit_value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
        value = find_attr_value_('framerate', node)
        if value is not None and 'framerate' not in already_processed:
            already_processed.add('framerate')
            self.framerate = value
            self.validate_digit_value(self.framerate)    # validate type digit_value
        value = find_attr_value_('maxbitrate', node)
        if value is not None and 'maxbitrate' not in already_processed:
            already_processed.add('maxbitrate')
            self.maxbitrate = value
            self.validate_digit_value(self.maxbitrate)    # validate type digit_value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            self.height = value
            self.validate_digit_value(self.height)    # validate type digit_value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
            self.validate_digit_value(self.width)    # validate type digit_value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class recording_video_mime_params


class param(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, param)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if param.subclass:
            return param.subclass(*args_, **kwargs_)
        else:
            return param(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='param', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('param')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='param')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='param', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='param'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='param', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class param


class content_element(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, content=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.content = _cast(None, content)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, content_element)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if content_element.subclass:
            return content_element.subclass(*args_, **kwargs_)
        else:
            return content_element(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='content_element', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('content_element')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='content_element')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='content_element', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='content_element'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='content_element', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class content_element


class record_track(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, media=None, direction=None, track_id=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.media = _cast(None, media)
        self.direction = _cast(None, direction)
        self.track_id = _cast(None, track_id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, record_track)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if record_track.subclass:
            return record_track.subclass(*args_, **kwargs_)
        else:
            return record_track(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_media(self): return self.media
    def set_media(self, media): self.media = media
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_track_id(self): return self.track_id
    def set_track_id(self, track_id): self.track_id = track_id
    def validate_record_track_media(self, value):
        # Validate type record_track_media, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio', 'video', 'audiovideo']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on record_track_media' % {"value" : value.encode("utf-8")} )
    def validate_record_track_direction(self, value):
        # Validate type record_track_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['send', 'recv']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on record_track_direction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='record_track', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('record_track')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='record_track')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='record_track', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='record_track'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.media is not None and 'media' not in already_processed:
            already_processed.add('media')
            outfile.write(' media=%s' % (quote_attrib(self.media), ))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (quote_attrib(self.direction), ))
        if self.track_id is not None and 'track_id' not in already_processed:
            already_processed.add('track_id')
            outfile.write(' track_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.track_id), input_name='track_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='record_track', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('media', node)
        if value is not None and 'media' not in already_processed:
            already_processed.add('media')
            self.media = value
            self.validate_record_track_media(self.media)    # validate type record_track_media
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
            self.validate_record_track_direction(self.direction)    # validate type record_track_direction
        value = find_attr_value_('track_id', node)
        if value is not None and 'track_id' not in already_processed:
            already_processed.add('track_id')
            self.track_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class record_track


class msg_payload(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, content_id=None, content_type=None, content_disposition='attachment', uri=None, msg_payload_content=None, msg_payload_uri=None):
        self.original_tagname_ = None
        self.content_id = _cast(None, content_id)
        self.content_type = _cast(None, content_type)
        self.content_disposition = _cast(None, content_disposition)
        self.uri = _cast(None, uri)
        self.msg_payload_content = msg_payload_content
        self.msg_payload_uri = msg_payload_uri
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, msg_payload)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if msg_payload.subclass:
            return msg_payload.subclass(*args_, **kwargs_)
        else:
            return msg_payload(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_msg_payload_content(self): return self.msg_payload_content
    def set_msg_payload_content(self, msg_payload_content): self.msg_payload_content = msg_payload_content
    def get_msg_payload_uri(self): return self.msg_payload_uri
    def set_msg_payload_uri(self, msg_payload_uri): self.msg_payload_uri = msg_payload_uri
    def get_content_id(self): return self.content_id
    def set_content_id(self, content_id): self.content_id = content_id
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_content_disposition(self): return self.content_disposition
    def set_content_disposition(self, content_disposition): self.content_disposition = content_disposition
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def hasContent_(self):
        if (
            self.msg_payload_content is not None or
            self.msg_payload_uri is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='msg_payload', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('msg_payload')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='msg_payload')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='msg_payload', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='msg_payload'):
        if self.content_id is not None and 'content_id' not in already_processed:
            already_processed.add('content_id')
            outfile.write(' content_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_id), input_name='content_id')), ))
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_type), input_name='content_type')), ))
        if self.content_disposition != "attachment" and 'content_disposition' not in already_processed:
            already_processed.add('content_disposition')
            outfile.write(' content_disposition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_disposition), input_name='content_disposition')), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='msg_payload', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.msg_payload_content is not None:
            self.msg_payload_content.export(outfile, level, namespace_, name_='msg_payload_content', pretty_print=pretty_print)
        if self.msg_payload_uri is not None:
            self.msg_payload_uri.export(outfile, level, namespace_, name_='msg_payload_uri', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('content_id', node)
        if value is not None and 'content_id' not in already_processed:
            already_processed.add('content_id')
            self.content_id = value
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('content_disposition', node)
        if value is not None and 'content_disposition' not in already_processed:
            already_processed.add('content_disposition')
            self.content_disposition = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'msg_payload_content':
            obj_ = msg_payload_contentType.factory()
            obj_.build(child_)
            self.msg_payload_content = obj_
            obj_.original_tagname_ = 'msg_payload_content'
        elif nodeName_ == 'msg_payload_uri':
            obj_ = msg_payload_uriType.factory()
            obj_.build(child_)
            self.msg_payload_uri = obj_
            obj_.original_tagname_ = 'msg_payload_uri'
# end class msg_payload


class conf_participant(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, call_id=None, audio=None, video=None, caption=None, region=None):
        self.original_tagname_ = None
        self.call_id = _cast(None, call_id)
        self.audio = _cast(None, audio)
        self.video = _cast(None, video)
        self.caption = _cast(None, caption)
        self.region = _cast(None, region)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, conf_participant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if conf_participant.subclass:
            return conf_participant.subclass(*args_, **kwargs_)
        else:
            return conf_participant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_call_id(self): return self.call_id
    def set_call_id(self, call_id): self.call_id = call_id
    def get_audio(self): return self.audio
    def set_audio(self, audio): self.audio = audio
    def get_video(self): return self.video
    def set_video(self, video): self.video = video
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def validate_media_direction(self, value):
        # Validate type media_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inactive', 'sendonly', 'recvonly', 'sendrecv']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_direction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conf_participant', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('conf_participant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conf_participant')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conf_participant', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conf_participant'):
        if self.call_id is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            outfile.write(' call_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.call_id), input_name='call_id')), ))
        if self.audio is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            outfile.write(' audio=%s' % (quote_attrib(self.audio), ))
        if self.video is not None and 'video' not in already_processed:
            already_processed.add('video')
            outfile.write(' video=%s' % (quote_attrib(self.video), ))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caption), input_name='caption')), ))
        if self.region is not None and 'region' not in already_processed:
            already_processed.add('region')
            outfile.write(' region=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.region), input_name='region')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='conf_participant', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('call_id', node)
        if value is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            self.call_id = value
        value = find_attr_value_('audio', node)
        if value is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            self.audio = value
            self.validate_media_direction(self.audio)    # validate type media_direction
        value = find_attr_value_('video', node)
        if value is not None and 'video' not in already_processed:
            already_processed.add('video')
            self.video = value
            self.validate_media_direction(self.video)    # validate type media_direction
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.add('region')
            self.region = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class conf_participant


class get_last_action(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, play=None, record=None, update_play=None, playcollect=None, playrecord=None, overlay=None, stop=None, join=None, unjoin=None, add_party=None, update_party=None, remove_party=None, send_dtmf=None, send_info=None, send_info_ack=None, transfer=None, redirect=None, hangup=None, get_call_info=None, add_ice_candidate=None, send_message=None, send_hangup_ack=None, get_last_event=None, speak=None, recognize=None, mrcp_update_action=None, set_asr_param=None, get_asr_param=None, set_tts_param=None, get_tts_param=None, define_grammar=None, send_event=None, dial=None, send_prack=None, send_prack_ack=None, send_answer_ack=None):
        self.original_tagname_ = None
        self.play = play
        self.record = record
        self.update_play = update_play
        self.playcollect = playcollect
        self.playrecord = playrecord
        self.overlay = overlay
        self.stop = stop
        self.join = join
        self.unjoin = unjoin
        self.add_party = add_party
        self.update_party = update_party
        self.remove_party = remove_party
        self.send_dtmf = send_dtmf
        self.send_info = send_info
        self.send_info_ack = send_info_ack
        self.transfer = transfer
        self.redirect = redirect
        self.hangup = hangup
        self.get_call_info = get_call_info
        self.add_ice_candidate = add_ice_candidate
        self.send_message = send_message
        self.send_hangup_ack = send_hangup_ack
        self.get_last_event = get_last_event
        self.speak = speak
        self.recognize = recognize
        self.mrcp_update_action = mrcp_update_action
        self.set_asr_param = set_asr_param
        self.get_asr_param = get_asr_param
        self.set_tts_param = set_tts_param
        self.get_tts_param = get_tts_param
        self.define_grammar = define_grammar
        self.send_event = send_event
        self.dial = dial
        self.send_prack = send_prack
        self.send_prack_ack = send_prack_ack
        self.send_answer_ack = send_answer_ack
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, get_last_action)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if get_last_action.subclass:
            return get_last_action.subclass(*args_, **kwargs_)
        else:
            return get_last_action(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_play(self): return self.play
    def set_play(self, play): self.play = play
    def get_record(self): return self.record
    def set_record(self, record): self.record = record
    def get_update_play(self): return self.update_play
    def set_update_play(self, update_play): self.update_play = update_play
    def get_playcollect(self): return self.playcollect
    def set_playcollect(self, playcollect): self.playcollect = playcollect
    def get_playrecord(self): return self.playrecord
    def set_playrecord(self, playrecord): self.playrecord = playrecord
    def get_overlay(self): return self.overlay
    def set_overlay(self, overlay): self.overlay = overlay
    def get_stop(self): return self.stop
    def set_stop(self, stop): self.stop = stop
    def get_join(self): return self.join
    def set_join(self, join): self.join = join
    def get_unjoin(self): return self.unjoin
    def set_unjoin(self, unjoin): self.unjoin = unjoin
    def get_add_party(self): return self.add_party
    def set_add_party(self, add_party): self.add_party = add_party
    def get_update_party(self): return self.update_party
    def set_update_party(self, update_party): self.update_party = update_party
    def get_remove_party(self): return self.remove_party
    def set_remove_party(self, remove_party): self.remove_party = remove_party
    def get_send_dtmf(self): return self.send_dtmf
    def set_send_dtmf(self, send_dtmf): self.send_dtmf = send_dtmf
    def get_send_info(self): return self.send_info
    def set_send_info(self, send_info): self.send_info = send_info
    def get_send_info_ack(self): return self.send_info_ack
    def set_send_info_ack(self, send_info_ack): self.send_info_ack = send_info_ack
    def get_transfer(self): return self.transfer
    def set_transfer(self, transfer): self.transfer = transfer
    def get_redirect(self): return self.redirect
    def set_redirect(self, redirect): self.redirect = redirect
    def get_hangup(self): return self.hangup
    def set_hangup(self, hangup): self.hangup = hangup
    def get_get_call_info(self): return self.get_call_info
    def set_get_call_info(self, get_call_info): self.get_call_info = get_call_info
    def get_add_ice_candidate(self): return self.add_ice_candidate
    def set_add_ice_candidate(self, add_ice_candidate): self.add_ice_candidate = add_ice_candidate
    def get_send_message(self): return self.send_message
    def set_send_message(self, send_message): self.send_message = send_message
    def get_send_hangup_ack(self): return self.send_hangup_ack
    def set_send_hangup_ack(self, send_hangup_ack): self.send_hangup_ack = send_hangup_ack
    def get_get_last_event(self): return self.get_last_event
    def set_get_last_event(self, get_last_event): self.get_last_event = get_last_event
    def get_speak(self): return self.speak
    def set_speak(self, speak): self.speak = speak
    def get_recognize(self): return self.recognize
    def set_recognize(self, recognize): self.recognize = recognize
    def get_mrcp_update_action(self): return self.mrcp_update_action
    def set_mrcp_update_action(self, mrcp_update_action): self.mrcp_update_action = mrcp_update_action
    def get_set_asr_param(self): return self.set_asr_param
    def set_set_asr_param(self, set_asr_param): self.set_asr_param = set_asr_param
    def get_get_asr_param(self): return self.get_asr_param
    def set_get_asr_param(self, get_asr_param): self.get_asr_param = get_asr_param
    def get_set_tts_param(self): return self.set_tts_param
    def set_set_tts_param(self, set_tts_param): self.set_tts_param = set_tts_param
    def get_get_tts_param(self): return self.get_tts_param
    def set_get_tts_param(self, get_tts_param): self.get_tts_param = get_tts_param
    def get_define_grammar(self): return self.define_grammar
    def set_define_grammar(self, define_grammar): self.define_grammar = define_grammar
    def get_send_event(self): return self.send_event
    def set_send_event(self, send_event): self.send_event = send_event
    def get_dial(self): return self.dial
    def set_dial(self, dial): self.dial = dial
    def get_send_prack(self): return self.send_prack
    def set_send_prack(self, send_prack): self.send_prack = send_prack
    def get_send_prack_ack(self): return self.send_prack_ack
    def set_send_prack_ack(self, send_prack_ack): self.send_prack_ack = send_prack_ack
    def get_send_answer_ack(self): return self.send_answer_ack
    def set_send_answer_ack(self, send_answer_ack): self.send_answer_ack = send_answer_ack
    def hasContent_(self):
        if (
            self.play is not None or
            self.record is not None or
            self.update_play is not None or
            self.playcollect is not None or
            self.playrecord is not None or
            self.overlay is not None or
            self.stop is not None or
            self.join is not None or
            self.unjoin is not None or
            self.add_party is not None or
            self.update_party is not None or
            self.remove_party is not None or
            self.send_dtmf is not None or
            self.send_info is not None or
            self.send_info_ack is not None or
            self.transfer is not None or
            self.redirect is not None or
            self.hangup is not None or
            self.get_call_info is not None or
            self.add_ice_candidate is not None or
            self.send_message is not None or
            self.send_hangup_ack is not None or
            self.get_last_event is not None or
            self.speak is not None or
            self.recognize is not None or
            self.mrcp_update_action is not None or
            self.set_asr_param is not None or
            self.get_asr_param is not None or
            self.set_tts_param is not None or
            self.get_tts_param is not None or
            self.define_grammar is not None or
            self.send_event is not None or
            self.dial is not None or
            self.send_prack is not None or
            self.send_prack_ack is not None or
            self.send_answer_ack is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='get_last_action', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('get_last_action')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='get_last_action')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='get_last_action', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='get_last_action'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='get_last_action', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.play is not None:
            self.play.export(outfile, level, namespace_, name_='play', pretty_print=pretty_print)
        if self.record is not None:
            self.record.export(outfile, level, namespace_, name_='record', pretty_print=pretty_print)
        if self.update_play is not None:
            self.update_play.export(outfile, level, namespace_, name_='update_play', pretty_print=pretty_print)
        if self.playcollect is not None:
            self.playcollect.export(outfile, level, namespace_, name_='playcollect', pretty_print=pretty_print)
        if self.playrecord is not None:
            self.playrecord.export(outfile, level, namespace_, name_='playrecord', pretty_print=pretty_print)
        if self.overlay is not None:
            self.overlay.export(outfile, level, namespace_, name_='overlay', pretty_print=pretty_print)
        if self.stop is not None:
            self.stop.export(outfile, level, namespace_, name_='stop', pretty_print=pretty_print)
        if self.join is not None:
            self.join.export(outfile, level, namespace_, name_='join', pretty_print=pretty_print)
        if self.unjoin is not None:
            self.unjoin.export(outfile, level, namespace_, name_='unjoin', pretty_print=pretty_print)
        if self.add_party is not None:
            self.add_party.export(outfile, level, namespace_, name_='add_party', pretty_print=pretty_print)
        if self.update_party is not None:
            self.update_party.export(outfile, level, namespace_, name_='update_party', pretty_print=pretty_print)
        if self.remove_party is not None:
            self.remove_party.export(outfile, level, namespace_, name_='remove_party', pretty_print=pretty_print)
        if self.send_dtmf is not None:
            self.send_dtmf.export(outfile, level, namespace_, name_='send_dtmf', pretty_print=pretty_print)
        if self.send_info is not None:
            self.send_info.export(outfile, level, namespace_, name_='send_info', pretty_print=pretty_print)
        if self.send_info_ack is not None:
            self.send_info_ack.export(outfile, level, namespace_, name_='send_info_ack', pretty_print=pretty_print)
        if self.transfer is not None:
            self.transfer.export(outfile, level, namespace_, name_='transfer', pretty_print=pretty_print)
        if self.redirect is not None:
            self.redirect.export(outfile, level, namespace_, name_='redirect', pretty_print=pretty_print)
        if self.hangup is not None:
            self.hangup.export(outfile, level, namespace_, name_='hangup', pretty_print=pretty_print)
        if self.get_call_info is not None:
            self.get_call_info.export(outfile, level, namespace_, name_='get_call_info', pretty_print=pretty_print)
        if self.add_ice_candidate is not None:
            self.add_ice_candidate.export(outfile, level, namespace_, name_='add_ice_candidate', pretty_print=pretty_print)
        if self.send_message is not None:
            self.send_message.export(outfile, level, namespace_, name_='send_message', pretty_print=pretty_print)
        if self.send_hangup_ack is not None:
            self.send_hangup_ack.export(outfile, level, namespace_, name_='send_hangup_ack', pretty_print=pretty_print)
        if self.get_last_event is not None:
            self.get_last_event.export(outfile, level, namespace_, name_='get_last_event', pretty_print=pretty_print)
        if self.speak is not None:
            self.speak.export(outfile, level, namespace_, name_='speak', pretty_print=pretty_print)
        if self.recognize is not None:
            self.recognize.export(outfile, level, namespace_, name_='recognize', pretty_print=pretty_print)
        if self.mrcp_update_action is not None:
            self.mrcp_update_action.export(outfile, level, namespace_, name_='mrcp-update-action', pretty_print=pretty_print)
        if self.set_asr_param is not None:
            self.set_asr_param.export(outfile, level, namespace_, name_='set-asr-param', pretty_print=pretty_print)
        if self.get_asr_param is not None:
            self.get_asr_param.export(outfile, level, namespace_, name_='get-asr-param', pretty_print=pretty_print)
        if self.set_tts_param is not None:
            self.set_tts_param.export(outfile, level, namespace_, name_='set-tts-param', pretty_print=pretty_print)
        if self.get_tts_param is not None:
            self.get_tts_param.export(outfile, level, namespace_, name_='get-tts-param', pretty_print=pretty_print)
        if self.define_grammar is not None:
            self.define_grammar.export(outfile, level, namespace_, name_='define-grammar', pretty_print=pretty_print)
        if self.send_event is not None:
            self.send_event.export(outfile, level, namespace_, name_='send_event', pretty_print=pretty_print)
        if self.dial is not None:
            self.dial.export(outfile, level, namespace_, name_='dial', pretty_print=pretty_print)
        if self.send_prack is not None:
            self.send_prack.export(outfile, level, namespace_, name_='send_prack', pretty_print=pretty_print)
        if self.send_prack_ack is not None:
            self.send_prack_ack.export(outfile, level, namespace_, name_='send_prack_ack', pretty_print=pretty_print)
        if self.send_answer_ack is not None:
            self.send_answer_ack.export(outfile, level, namespace_, name_='send_answer_ack', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'play':
            obj_ = play.factory()
            obj_.build(child_)
            self.play = obj_
            obj_.original_tagname_ = 'play'
        elif nodeName_ == 'record':
            obj_ = record.factory()
            obj_.build(child_)
            self.record = obj_
            obj_.original_tagname_ = 'record'
        elif nodeName_ == 'update_play':
            obj_ = update_play.factory()
            obj_.build(child_)
            self.update_play = obj_
            obj_.original_tagname_ = 'update_play'
        elif nodeName_ == 'playcollect':
            obj_ = playcollect.factory()
            obj_.build(child_)
            self.playcollect = obj_
            obj_.original_tagname_ = 'playcollect'
        elif nodeName_ == 'playrecord':
            obj_ = playrecord.factory()
            obj_.build(child_)
            self.playrecord = obj_
            obj_.original_tagname_ = 'playrecord'
        elif nodeName_ == 'overlay':
            obj_ = overlay.factory()
            obj_.build(child_)
            self.overlay = obj_
            obj_.original_tagname_ = 'overlay'
        elif nodeName_ == 'stop':
            obj_ = stop.factory()
            obj_.build(child_)
            self.stop = obj_
            obj_.original_tagname_ = 'stop'
        elif nodeName_ == 'join':
            obj_ = join.factory()
            obj_.build(child_)
            self.join = obj_
            obj_.original_tagname_ = 'join'
        elif nodeName_ == 'unjoin':
            obj_ = unjoin.factory()
            obj_.build(child_)
            self.unjoin = obj_
            obj_.original_tagname_ = 'unjoin'
        elif nodeName_ == 'add_party':
            obj_ = add_party.factory()
            obj_.build(child_)
            self.add_party = obj_
            obj_.original_tagname_ = 'add_party'
        elif nodeName_ == 'update_party':
            obj_ = update_party.factory()
            obj_.build(child_)
            self.update_party = obj_
            obj_.original_tagname_ = 'update_party'
        elif nodeName_ == 'remove_party':
            obj_ = remove_party.factory()
            obj_.build(child_)
            self.remove_party = obj_
            obj_.original_tagname_ = 'remove_party'
        elif nodeName_ == 'send_dtmf':
            obj_ = send_dtmf.factory()
            obj_.build(child_)
            self.send_dtmf = obj_
            obj_.original_tagname_ = 'send_dtmf'
        elif nodeName_ == 'send_info':
            obj_ = send_info.factory()
            obj_.build(child_)
            self.send_info = obj_
            obj_.original_tagname_ = 'send_info'
        elif nodeName_ == 'send_info_ack':
            obj_ = send_info_ack.factory()
            obj_.build(child_)
            self.send_info_ack = obj_
            obj_.original_tagname_ = 'send_info_ack'
        elif nodeName_ == 'transfer':
            obj_ = transfer.factory()
            obj_.build(child_)
            self.transfer = obj_
            obj_.original_tagname_ = 'transfer'
        elif nodeName_ == 'redirect':
            obj_ = redirect.factory()
            obj_.build(child_)
            self.redirect = obj_
            obj_.original_tagname_ = 'redirect'
        elif nodeName_ == 'hangup':
            obj_ = hangup.factory()
            obj_.build(child_)
            self.hangup = obj_
            obj_.original_tagname_ = 'hangup'
        elif nodeName_ == 'get_call_info':
            obj_ = get_call_info.factory()
            obj_.build(child_)
            self.get_call_info = obj_
            obj_.original_tagname_ = 'get_call_info'
        elif nodeName_ == 'add_ice_candidate':
            obj_ = add_ice_candidate.factory()
            obj_.build(child_)
            self.add_ice_candidate = obj_
            obj_.original_tagname_ = 'add_ice_candidate'
        elif nodeName_ == 'send_message':
            obj_ = send_message.factory()
            obj_.build(child_)
            self.send_message = obj_
            obj_.original_tagname_ = 'send_message'
        elif nodeName_ == 'send_hangup_ack':
            obj_ = send_hangup_ack.factory()
            obj_.build(child_)
            self.send_hangup_ack = obj_
            obj_.original_tagname_ = 'send_hangup_ack'
        elif nodeName_ == 'get_last_event':
            obj_ = get_last_event.factory()
            obj_.build(child_)
            self.get_last_event = obj_
            obj_.original_tagname_ = 'get_last_event'
        elif nodeName_ == 'speak':
            obj_ = speak.factory()
            obj_.build(child_)
            self.speak = obj_
            obj_.original_tagname_ = 'speak'
        elif nodeName_ == 'recognize':
            obj_ = recognize.factory()
            obj_.build(child_)
            self.recognize = obj_
            obj_.original_tagname_ = 'recognize'
        elif nodeName_ == 'mrcp-update-action':
            obj_ = mrcp_update_action.factory()
            obj_.build(child_)
            self.mrcp_update_action = obj_
            obj_.original_tagname_ = 'mrcp-update-action'
        elif nodeName_ == 'set-asr-param':
            obj_ = set_asr_param.factory()
            obj_.build(child_)
            self.set_asr_param = obj_
            obj_.original_tagname_ = 'set-asr-param'
        elif nodeName_ == 'get-asr-param':
            obj_ = get_asr_param.factory()
            obj_.build(child_)
            self.get_asr_param = obj_
            obj_.original_tagname_ = 'get-asr-param'
        elif nodeName_ == 'set-tts-param':
            obj_ = set_tts_param.factory()
            obj_.build(child_)
            self.set_tts_param = obj_
            obj_.original_tagname_ = 'set-tts-param'
        elif nodeName_ == 'get-tts-param':
            obj_ = get_tts_param.factory()
            obj_.build(child_)
            self.get_tts_param = obj_
            obj_.original_tagname_ = 'get-tts-param'
        elif nodeName_ == 'define-grammar':
            obj_ = define_grammar.factory()
            obj_.build(child_)
            self.define_grammar = obj_
            obj_.original_tagname_ = 'define-grammar'
        elif nodeName_ == 'send_event':
            obj_ = send_event.factory()
            obj_.build(child_)
            self.send_event = obj_
            obj_.original_tagname_ = 'send_event'
        elif nodeName_ == 'dial':
            obj_ = dial.factory()
            obj_.build(child_)
            self.dial = obj_
            obj_.original_tagname_ = 'dial'
        elif nodeName_ == 'send_prack':
            obj_ = send_prack.factory()
            obj_.build(child_)
            self.send_prack = obj_
            obj_.original_tagname_ = 'send_prack'
        elif nodeName_ == 'send_prack_ack':
            obj_ = send_prack_ack.factory()
            obj_.build(child_)
            self.send_prack_ack = obj_
            obj_.original_tagname_ = 'send_prack_ack'
        elif nodeName_ == 'send_answer_ack':
            obj_ = send_answer_ack.factory()
            obj_.build(child_)
            self.send_answer_ack = obj_
            obj_.original_tagname_ = 'send_answer_ack'
# end class get_last_action


class get_last_event(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, event=None):
        self.original_tagname_ = None
        self.event = event
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, get_last_event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if get_last_event.subclass:
            return get_last_event.subclass(*args_, **kwargs_)
        else:
            return get_last_event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def hasContent_(self):
        if (
            self.event is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='get_last_event', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('get_last_event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='get_last_event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='get_last_event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='get_last_event'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='get_last_event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.event is not None:
            self.event.export(outfile, level, namespace_, name_='event', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'event':
            obj_ = event.factory()
            obj_.build(child_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
# end class get_last_event


class add_party(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, conf_id=None, audio='recvonly', video='recvonly', caption=None, caption_duration=None, clamp_dtmf=None, auto_gain_control=None, echo_cancellation=None, mute='no', tx_mute='no', privilege='no', mode='normal', region='0', primary_video_source=None):
        self.original_tagname_ = None
        self.conf_id = _cast(None, conf_id)
        self.audio = _cast(None, audio)
        self.video = _cast(None, video)
        self.caption = _cast(None, caption)
        self.caption_duration = _cast(None, caption_duration)
        self.clamp_dtmf = _cast(None, clamp_dtmf)
        self.auto_gain_control = _cast(None, auto_gain_control)
        self.echo_cancellation = _cast(None, echo_cancellation)
        self.mute = _cast(None, mute)
        self.tx_mute = _cast(None, tx_mute)
        self.privilege = _cast(None, privilege)
        self.mode = _cast(None, mode)
        self.region = _cast(None, region)
        self.primary_video_source = _cast(None, primary_video_source)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, add_party)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if add_party.subclass:
            return add_party.subclass(*args_, **kwargs_)
        else:
            return add_party(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_conf_id(self): return self.conf_id
    def set_conf_id(self, conf_id): self.conf_id = conf_id
    def get_audio(self): return self.audio
    def set_audio(self, audio): self.audio = audio
    def get_video(self): return self.video
    def set_video(self, video): self.video = video
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_caption_duration(self): return self.caption_duration
    def set_caption_duration(self, caption_duration): self.caption_duration = caption_duration
    def get_clamp_dtmf(self): return self.clamp_dtmf
    def set_clamp_dtmf(self, clamp_dtmf): self.clamp_dtmf = clamp_dtmf
    def get_auto_gain_control(self): return self.auto_gain_control
    def set_auto_gain_control(self, auto_gain_control): self.auto_gain_control = auto_gain_control
    def get_echo_cancellation(self): return self.echo_cancellation
    def set_echo_cancellation(self, echo_cancellation): self.echo_cancellation = echo_cancellation
    def get_mute(self): return self.mute
    def set_mute(self, mute): self.mute = mute
    def get_tx_mute(self): return self.tx_mute
    def set_tx_mute(self, tx_mute): self.tx_mute = tx_mute
    def get_privilege(self): return self.privilege
    def set_privilege(self, privilege): self.privilege = privilege
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def get_primary_video_source(self): return self.primary_video_source
    def set_primary_video_source(self, primary_video_source): self.primary_video_source = primary_video_source
    def validate_media_direction(self, value):
        # Validate type media_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inactive', 'sendonly', 'recvonly', 'sendrecv']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_direction' % {"value" : value.encode("utf-8")} )
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def validate_privilege_option(self, value):
        # Validate type privilege_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no', 'enhanced']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on privilege_option' % {"value" : value.encode("utf-8")} )
    def validate_conf_party_mode(self, value):
        # Validate type conf_party_mode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['normal', 'coach', 'pupil']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on conf_party_mode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='add_party', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('add_party')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='add_party')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='add_party', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='add_party'):
        if self.conf_id is not None and 'conf_id' not in already_processed:
            already_processed.add('conf_id')
            outfile.write(' conf_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.conf_id), input_name='conf_id')), ))
        if self.audio != "recvonly" and 'audio' not in already_processed:
            already_processed.add('audio')
            outfile.write(' audio=%s' % (quote_attrib(self.audio), ))
        if self.video != "recvonly" and 'video' not in already_processed:
            already_processed.add('video')
            outfile.write(' video=%s' % (quote_attrib(self.video), ))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caption), input_name='caption')), ))
        if self.caption_duration is not None and 'caption_duration' not in already_processed:
            already_processed.add('caption_duration')
            outfile.write(' caption_duration=%s' % (quote_attrib(self.caption_duration), ))
        if self.clamp_dtmf is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            outfile.write(' clamp_dtmf=%s' % (quote_attrib(self.clamp_dtmf), ))
        if self.auto_gain_control is not None and 'auto_gain_control' not in already_processed:
            already_processed.add('auto_gain_control')
            outfile.write(' auto_gain_control=%s' % (quote_attrib(self.auto_gain_control), ))
        if self.echo_cancellation is not None and 'echo_cancellation' not in already_processed:
            already_processed.add('echo_cancellation')
            outfile.write(' echo_cancellation=%s' % (quote_attrib(self.echo_cancellation), ))
        if self.mute != "no" and 'mute' not in already_processed:
            already_processed.add('mute')
            outfile.write(' mute=%s' % (quote_attrib(self.mute), ))
        if self.tx_mute != "no" and 'tx_mute' not in already_processed:
            already_processed.add('tx_mute')
            outfile.write(' tx_mute=%s' % (quote_attrib(self.tx_mute), ))
        if self.privilege != "no" and 'privilege' not in already_processed:
            already_processed.add('privilege')
            outfile.write(' privilege=%s' % (quote_attrib(self.privilege), ))
        if self.mode != "normal" and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (quote_attrib(self.mode), ))
        if self.region != "0" and 'region' not in already_processed:
            already_processed.add('region')
            outfile.write(' region=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.region), input_name='region')), ))
        if self.primary_video_source is not None and 'primary_video_source' not in already_processed:
            already_processed.add('primary_video_source')
            outfile.write(' primary_video_source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.primary_video_source), input_name='primary_video_source')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='add_party', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conf_id', node)
        if value is not None and 'conf_id' not in already_processed:
            already_processed.add('conf_id')
            self.conf_id = value
        value = find_attr_value_('audio', node)
        if value is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            self.audio = value
            self.validate_media_direction(self.audio)    # validate type media_direction
        value = find_attr_value_('video', node)
        if value is not None and 'video' not in already_processed:
            already_processed.add('video')
            self.video = value
            self.validate_media_direction(self.video)    # validate type media_direction
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
        value = find_attr_value_('caption_duration', node)
        if value is not None and 'caption_duration' not in already_processed:
            already_processed.add('caption_duration')
            self.caption_duration = value
            self.validate_time_value(self.caption_duration)    # validate type time_value
        value = find_attr_value_('clamp_dtmf', node)
        if value is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            self.clamp_dtmf = value
            self.validate_boolean_type(self.clamp_dtmf)    # validate type boolean_type
        value = find_attr_value_('auto_gain_control', node)
        if value is not None and 'auto_gain_control' not in already_processed:
            already_processed.add('auto_gain_control')
            self.auto_gain_control = value
            self.validate_boolean_type(self.auto_gain_control)    # validate type boolean_type
        value = find_attr_value_('echo_cancellation', node)
        if value is not None and 'echo_cancellation' not in already_processed:
            already_processed.add('echo_cancellation')
            self.echo_cancellation = value
            self.validate_boolean_type(self.echo_cancellation)    # validate type boolean_type
        value = find_attr_value_('mute', node)
        if value is not None and 'mute' not in already_processed:
            already_processed.add('mute')
            self.mute = value
            self.validate_boolean_type(self.mute)    # validate type boolean_type
        value = find_attr_value_('tx_mute', node)
        if value is not None and 'tx_mute' not in already_processed:
            already_processed.add('tx_mute')
            self.tx_mute = value
            self.validate_boolean_type(self.tx_mute)    # validate type boolean_type
        value = find_attr_value_('privilege', node)
        if value is not None and 'privilege' not in already_processed:
            already_processed.add('privilege')
            self.privilege = value
            self.validate_privilege_option(self.privilege)    # validate type privilege_option
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
            self.validate_conf_party_mode(self.mode)    # validate type conf_party_mode
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.add('region')
            self.region = value
        value = find_attr_value_('primary_video_source', node)
        if value is not None and 'primary_video_source' not in already_processed:
            already_processed.add('primary_video_source')
            self.primary_video_source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class add_party


class update_party(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, conf_id=None, audio=None, video=None, caption=None, caption_duration=None, clamp_dtmf=None, auto_gain_control=None, echo_cancellation=None, mute=None, tx_mute=None, privilege=None, mode=None, region=None, primary_video_source=None):
        self.original_tagname_ = None
        self.conf_id = _cast(None, conf_id)
        self.audio = _cast(None, audio)
        self.video = _cast(None, video)
        self.caption = _cast(None, caption)
        self.caption_duration = _cast(None, caption_duration)
        self.clamp_dtmf = _cast(None, clamp_dtmf)
        self.auto_gain_control = _cast(None, auto_gain_control)
        self.echo_cancellation = _cast(None, echo_cancellation)
        self.mute = _cast(None, mute)
        self.tx_mute = _cast(None, tx_mute)
        self.privilege = _cast(None, privilege)
        self.mode = _cast(None, mode)
        self.region = _cast(None, region)
        self.primary_video_source = _cast(None, primary_video_source)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, update_party)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if update_party.subclass:
            return update_party.subclass(*args_, **kwargs_)
        else:
            return update_party(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_conf_id(self): return self.conf_id
    def set_conf_id(self, conf_id): self.conf_id = conf_id
    def get_audio(self): return self.audio
    def set_audio(self, audio): self.audio = audio
    def get_video(self): return self.video
    def set_video(self, video): self.video = video
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_caption_duration(self): return self.caption_duration
    def set_caption_duration(self, caption_duration): self.caption_duration = caption_duration
    def get_clamp_dtmf(self): return self.clamp_dtmf
    def set_clamp_dtmf(self, clamp_dtmf): self.clamp_dtmf = clamp_dtmf
    def get_auto_gain_control(self): return self.auto_gain_control
    def set_auto_gain_control(self, auto_gain_control): self.auto_gain_control = auto_gain_control
    def get_echo_cancellation(self): return self.echo_cancellation
    def set_echo_cancellation(self, echo_cancellation): self.echo_cancellation = echo_cancellation
    def get_mute(self): return self.mute
    def set_mute(self, mute): self.mute = mute
    def get_tx_mute(self): return self.tx_mute
    def set_tx_mute(self, tx_mute): self.tx_mute = tx_mute
    def get_privilege(self): return self.privilege
    def set_privilege(self, privilege): self.privilege = privilege
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def get_primary_video_source(self): return self.primary_video_source
    def set_primary_video_source(self, primary_video_source): self.primary_video_source = primary_video_source
    def validate_media_direction(self, value):
        # Validate type media_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inactive', 'sendonly', 'recvonly', 'sendrecv']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_direction' % {"value" : value.encode("utf-8")} )
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def validate_privilege_option(self, value):
        # Validate type privilege_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no', 'enhanced']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on privilege_option' % {"value" : value.encode("utf-8")} )
    def validate_conf_party_mode(self, value):
        # Validate type conf_party_mode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['normal', 'coach', 'pupil']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on conf_party_mode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='update_party', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('update_party')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='update_party')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='update_party', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='update_party'):
        if self.conf_id is not None and 'conf_id' not in already_processed:
            already_processed.add('conf_id')
            outfile.write(' conf_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.conf_id), input_name='conf_id')), ))
        if self.audio is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            outfile.write(' audio=%s' % (quote_attrib(self.audio), ))
        if self.video is not None and 'video' not in already_processed:
            already_processed.add('video')
            outfile.write(' video=%s' % (quote_attrib(self.video), ))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caption), input_name='caption')), ))
        if self.caption_duration is not None and 'caption_duration' not in already_processed:
            already_processed.add('caption_duration')
            outfile.write(' caption_duration=%s' % (quote_attrib(self.caption_duration), ))
        if self.clamp_dtmf is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            outfile.write(' clamp_dtmf=%s' % (quote_attrib(self.clamp_dtmf), ))
        if self.auto_gain_control is not None and 'auto_gain_control' not in already_processed:
            already_processed.add('auto_gain_control')
            outfile.write(' auto_gain_control=%s' % (quote_attrib(self.auto_gain_control), ))
        if self.echo_cancellation is not None and 'echo_cancellation' not in already_processed:
            already_processed.add('echo_cancellation')
            outfile.write(' echo_cancellation=%s' % (quote_attrib(self.echo_cancellation), ))
        if self.mute is not None and 'mute' not in already_processed:
            already_processed.add('mute')
            outfile.write(' mute=%s' % (quote_attrib(self.mute), ))
        if self.tx_mute is not None and 'tx_mute' not in already_processed:
            already_processed.add('tx_mute')
            outfile.write(' tx_mute=%s' % (quote_attrib(self.tx_mute), ))
        if self.privilege is not None and 'privilege' not in already_processed:
            already_processed.add('privilege')
            outfile.write(' privilege=%s' % (quote_attrib(self.privilege), ))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (quote_attrib(self.mode), ))
        if self.region is not None and 'region' not in already_processed:
            already_processed.add('region')
            outfile.write(' region=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.region), input_name='region')), ))
        if self.primary_video_source is not None and 'primary_video_source' not in already_processed:
            already_processed.add('primary_video_source')
            outfile.write(' primary_video_source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.primary_video_source), input_name='primary_video_source')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='update_party', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conf_id', node)
        if value is not None and 'conf_id' not in already_processed:
            already_processed.add('conf_id')
            self.conf_id = value
        value = find_attr_value_('audio', node)
        if value is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            self.audio = value
            self.validate_media_direction(self.audio)    # validate type media_direction
        value = find_attr_value_('video', node)
        if value is not None and 'video' not in already_processed:
            already_processed.add('video')
            self.video = value
            self.validate_media_direction(self.video)    # validate type media_direction
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
        value = find_attr_value_('caption_duration', node)
        if value is not None and 'caption_duration' not in already_processed:
            already_processed.add('caption_duration')
            self.caption_duration = value
            self.validate_time_value(self.caption_duration)    # validate type time_value
        value = find_attr_value_('clamp_dtmf', node)
        if value is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            self.clamp_dtmf = value
            self.validate_boolean_type(self.clamp_dtmf)    # validate type boolean_type
        value = find_attr_value_('auto_gain_control', node)
        if value is not None and 'auto_gain_control' not in already_processed:
            already_processed.add('auto_gain_control')
            self.auto_gain_control = value
            self.validate_boolean_type(self.auto_gain_control)    # validate type boolean_type
        value = find_attr_value_('echo_cancellation', node)
        if value is not None and 'echo_cancellation' not in already_processed:
            already_processed.add('echo_cancellation')
            self.echo_cancellation = value
            self.validate_boolean_type(self.echo_cancellation)    # validate type boolean_type
        value = find_attr_value_('mute', node)
        if value is not None and 'mute' not in already_processed:
            already_processed.add('mute')
            self.mute = value
            self.validate_boolean_type(self.mute)    # validate type boolean_type
        value = find_attr_value_('tx_mute', node)
        if value is not None and 'tx_mute' not in already_processed:
            already_processed.add('tx_mute')
            self.tx_mute = value
            self.validate_boolean_type(self.tx_mute)    # validate type boolean_type
        value = find_attr_value_('privilege', node)
        if value is not None and 'privilege' not in already_processed:
            already_processed.add('privilege')
            self.privilege = value
            self.validate_privilege_option(self.privilege)    # validate type privilege_option
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
            self.validate_conf_party_mode(self.mode)    # validate type conf_party_mode
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.add('region')
            self.region = value
        value = find_attr_value_('primary_video_source', node)
        if value is not None and 'primary_video_source' not in already_processed:
            already_processed.add('primary_video_source')
            self.primary_video_source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class update_party


class remove_party(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, conf_id=None):
        self.original_tagname_ = None
        self.conf_id = _cast(None, conf_id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remove_party)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remove_party.subclass:
            return remove_party.subclass(*args_, **kwargs_)
        else:
            return remove_party(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_conf_id(self): return self.conf_id
    def set_conf_id(self, conf_id): self.conf_id = conf_id
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='remove_party', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remove_party')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remove_party')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='remove_party', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='remove_party'):
        if self.conf_id is not None and 'conf_id' not in already_processed:
            already_processed.add('conf_id')
            outfile.write(' conf_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.conf_id), input_name='conf_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='remove_party', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conf_id', node)
        if value is not None and 'conf_id' not in already_processed:
            already_processed.add('conf_id')
            self.conf_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class remove_party


class join(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, call_id=None, audio='sendrecv', video='sendrecv', audio_transcode='yes', video_transcode='yes', media_path_optimize='no'):
        self.original_tagname_ = None
        self.call_id = _cast(None, call_id)
        self.audio = _cast(None, audio)
        self.video = _cast(None, video)
        self.audio_transcode = _cast(None, audio_transcode)
        self.video_transcode = _cast(None, video_transcode)
        self.media_path_optimize = _cast(None, media_path_optimize)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, join)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if join.subclass:
            return join.subclass(*args_, **kwargs_)
        else:
            return join(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_call_id(self): return self.call_id
    def set_call_id(self, call_id): self.call_id = call_id
    def get_audio(self): return self.audio
    def set_audio(self, audio): self.audio = audio
    def get_video(self): return self.video
    def set_video(self, video): self.video = video
    def get_audio_transcode(self): return self.audio_transcode
    def set_audio_transcode(self, audio_transcode): self.audio_transcode = audio_transcode
    def get_video_transcode(self): return self.video_transcode
    def set_video_transcode(self, video_transcode): self.video_transcode = video_transcode
    def get_media_path_optimize(self): return self.media_path_optimize
    def set_media_path_optimize(self, media_path_optimize): self.media_path_optimize = media_path_optimize
    def validate_media_direction(self, value):
        # Validate type media_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inactive', 'sendonly', 'recvonly', 'sendrecv']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_direction' % {"value" : value.encode("utf-8")} )
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='join', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('join')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='join')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='join', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='join'):
        if self.call_id is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            outfile.write(' call_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.call_id), input_name='call_id')), ))
        if self.audio != "sendrecv" and 'audio' not in already_processed:
            already_processed.add('audio')
            outfile.write(' audio=%s' % (quote_attrib(self.audio), ))
        if self.video != "sendrecv" and 'video' not in already_processed:
            already_processed.add('video')
            outfile.write(' video=%s' % (quote_attrib(self.video), ))
        if self.audio_transcode != "yes" and 'audio_transcode' not in already_processed:
            already_processed.add('audio_transcode')
            outfile.write(' audio_transcode=%s' % (quote_attrib(self.audio_transcode), ))
        if self.video_transcode != "yes" and 'video_transcode' not in already_processed:
            already_processed.add('video_transcode')
            outfile.write(' video_transcode=%s' % (quote_attrib(self.video_transcode), ))
        if self.media_path_optimize != "no" and 'media_path_optimize' not in already_processed:
            already_processed.add('media_path_optimize')
            outfile.write(' media_path_optimize=%s' % (quote_attrib(self.media_path_optimize), ))
    def exportChildren(self, outfile, level, namespace_='', name_='join', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('call_id', node)
        if value is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            self.call_id = value
        value = find_attr_value_('audio', node)
        if value is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            self.audio = value
            self.validate_media_direction(self.audio)    # validate type media_direction
        value = find_attr_value_('video', node)
        if value is not None and 'video' not in already_processed:
            already_processed.add('video')
            self.video = value
            self.validate_media_direction(self.video)    # validate type media_direction
        value = find_attr_value_('audio_transcode', node)
        if value is not None and 'audio_transcode' not in already_processed:
            already_processed.add('audio_transcode')
            self.audio_transcode = value
            self.validate_boolean_type(self.audio_transcode)    # validate type boolean_type
        value = find_attr_value_('video_transcode', node)
        if value is not None and 'video_transcode' not in already_processed:
            already_processed.add('video_transcode')
            self.video_transcode = value
            self.validate_boolean_type(self.video_transcode)    # validate type boolean_type
        value = find_attr_value_('media_path_optimize', node)
        if value is not None and 'media_path_optimize' not in already_processed:
            already_processed.add('media_path_optimize')
            self.media_path_optimize = value
            self.validate_boolean_type(self.media_path_optimize)    # validate type boolean_type
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class join


class unjoin(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, call_id=None, audio='sendrecv', video='sendrecv'):
        self.original_tagname_ = None
        self.call_id = _cast(None, call_id)
        self.audio = _cast(None, audio)
        self.video = _cast(None, video)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unjoin)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unjoin.subclass:
            return unjoin.subclass(*args_, **kwargs_)
        else:
            return unjoin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_call_id(self): return self.call_id
    def set_call_id(self, call_id): self.call_id = call_id
    def get_audio(self): return self.audio
    def set_audio(self, audio): self.audio = audio
    def get_video(self): return self.video
    def set_video(self, video): self.video = video
    def validate_media_direction(self, value):
        # Validate type media_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inactive', 'sendonly', 'recvonly', 'sendrecv']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_direction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='unjoin', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unjoin')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unjoin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='unjoin', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='unjoin'):
        if self.call_id is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            outfile.write(' call_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.call_id), input_name='call_id')), ))
        if self.audio != "sendrecv" and 'audio' not in already_processed:
            already_processed.add('audio')
            outfile.write(' audio=%s' % (quote_attrib(self.audio), ))
        if self.video != "sendrecv" and 'video' not in already_processed:
            already_processed.add('video')
            outfile.write(' video=%s' % (quote_attrib(self.video), ))
    def exportChildren(self, outfile, level, namespace_='', name_='unjoin', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('call_id', node)
        if value is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            self.call_id = value
        value = find_attr_value_('audio', node)
        if value is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            self.audio = value
            self.validate_media_direction(self.audio)    # validate type media_direction
        value = find_attr_value_('video', node)
        if value is not None and 'video' not in already_processed:
            already_processed.add('video')
            self.video = value
            self.validate_media_direction(self.video)    # validate type media_direction
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class unjoin


class transfer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, call_id=None, uri=None):
        self.original_tagname_ = None
        self.call_id = _cast(None, call_id)
        self.uri = _cast(None, uri)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transfer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transfer.subclass:
            return transfer.subclass(*args_, **kwargs_)
        else:
            return transfer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_call_id(self): return self.call_id
    def set_call_id(self, call_id): self.call_id = call_id
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transfer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transfer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transfer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transfer', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transfer'):
        if self.call_id is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            outfile.write(' call_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.call_id), input_name='call_id')), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='transfer', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('call_id', node)
        if value is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            self.call_id = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class transfer


class redirect(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uri=None):
        self.original_tagname_ = None
        self.uri = _cast(None, uri)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, redirect)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if redirect.subclass:
            return redirect.subclass(*args_, **kwargs_)
        else:
            return redirect(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='redirect', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('redirect')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='redirect')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='redirect', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='redirect'):
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='redirect', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class redirect


class hangup(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, content_type=None, content=None, reason=None):
        self.original_tagname_ = None
        self.content_type = _cast(None, content_type)
        self.content = _cast(None, content)
        self.reason = _cast(None, reason)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hangup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hangup.subclass:
            return hangup.subclass(*args_, **kwargs_)
        else:
            return hangup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='hangup', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hangup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hangup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='hangup', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='hangup'):
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_type), input_name='content_type')), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
        if self.reason is not None and 'reason' not in already_processed:
            already_processed.add('reason')
            outfile.write(' reason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reason), input_name='reason')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='hangup', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
        value = find_attr_value_('reason', node)
        if value is not None and 'reason' not in already_processed:
            already_processed.add('reason')
            self.reason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class hangup


class dial(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uri=None, called_uri=None, caller_uri=None, caller_display_name=None, cpa=None, cpa_profile=None, codec_profile=None, timeout=None, content_type=None, content=None, answer_ack_mode=None, prack_mode=None, prack_level=None, sip_headers=None):
        self.original_tagname_ = None
        self.uri = _cast(None, uri)
        self.called_uri = _cast(None, called_uri)
        self.caller_uri = _cast(None, caller_uri)
        self.caller_display_name = _cast(None, caller_display_name)
        self.cpa = _cast(None, cpa)
        self.cpa_profile = _cast(None, cpa_profile)
        self.codec_profile = _cast(None, codec_profile)
        self.timeout = _cast(None, timeout)
        self.content_type = _cast(None, content_type)
        self.content = _cast(None, content)
        self.answer_ack_mode = _cast(None, answer_ack_mode)
        self.prack_mode = _cast(None, prack_mode)
        self.prack_level = _cast(None, prack_level)
        self.sip_headers = sip_headers
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dial)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dial.subclass:
            return dial.subclass(*args_, **kwargs_)
        else:
            return dial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sip_headers(self): return self.sip_headers
    def set_sip_headers(self, sip_headers): self.sip_headers = sip_headers
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_called_uri(self): return self.called_uri
    def set_called_uri(self, called_uri): self.called_uri = called_uri
    def get_caller_uri(self): return self.caller_uri
    def set_caller_uri(self, caller_uri): self.caller_uri = caller_uri
    def get_caller_display_name(self): return self.caller_display_name
    def set_caller_display_name(self, caller_display_name): self.caller_display_name = caller_display_name
    def get_cpa(self): return self.cpa
    def set_cpa(self, cpa): self.cpa = cpa
    def get_cpa_profile(self): return self.cpa_profile
    def set_cpa_profile(self, cpa_profile): self.cpa_profile = cpa_profile
    def get_codec_profile(self): return self.codec_profile
    def set_codec_profile(self, codec_profile): self.codec_profile = codec_profile
    def get_timeout(self): return self.timeout
    def set_timeout(self, timeout): self.timeout = timeout
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_answer_ack_mode(self): return self.answer_ack_mode
    def set_answer_ack_mode(self, answer_ack_mode): self.answer_ack_mode = answer_ack_mode
    def get_prack_mode(self): return self.prack_mode
    def set_prack_mode(self, prack_mode): self.prack_mode = prack_mode
    def get_prack_level(self): return self.prack_level
    def set_prack_level(self, prack_level): self.prack_level = prack_level
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_ack_mode_option(self, value):
        # Validate type ack_mode_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['automatic', 'manual']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ack_mode_option' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.sip_headers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dial', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dial')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dial', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dial'):
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
        if self.called_uri is not None and 'called_uri' not in already_processed:
            already_processed.add('called_uri')
            outfile.write(' called_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.called_uri), input_name='called_uri')), ))
        if self.caller_uri is not None and 'caller_uri' not in already_processed:
            already_processed.add('caller_uri')
            outfile.write(' caller_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caller_uri), input_name='caller_uri')), ))
        if self.caller_display_name is not None and 'caller_display_name' not in already_processed:
            already_processed.add('caller_display_name')
            outfile.write(' caller_display_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caller_display_name), input_name='caller_display_name')), ))
        if self.cpa is not None and 'cpa' not in already_processed:
            already_processed.add('cpa')
            outfile.write(' cpa=%s' % (quote_attrib(self.cpa), ))
        if self.cpa_profile is not None and 'cpa_profile' not in already_processed:
            already_processed.add('cpa_profile')
            outfile.write(' cpa_profile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cpa_profile), input_name='cpa_profile')), ))
        if self.codec_profile is not None and 'codec_profile' not in already_processed:
            already_processed.add('codec_profile')
            outfile.write(' codec_profile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codec_profile), input_name='codec_profile')), ))
        if self.timeout is not None and 'timeout' not in already_processed:
            already_processed.add('timeout')
            outfile.write(' timeout=%s' % (quote_attrib(self.timeout), ))
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_type), input_name='content_type')), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
        if self.answer_ack_mode is not None and 'answer_ack_mode' not in already_processed:
            already_processed.add('answer_ack_mode')
            outfile.write(' answer_ack_mode=%s' % (quote_attrib(self.answer_ack_mode), ))
        if self.prack_mode is not None and 'prack_mode' not in already_processed:
            already_processed.add('prack_mode')
            outfile.write(' prack_mode=%s' % (quote_attrib(self.prack_mode), ))
        if self.prack_level is not None and 'prack_level' not in already_processed:
            already_processed.add('prack_level')
            outfile.write(' prack_level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prack_level), input_name='prack_level')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='dial', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sip_headers is not None:
            self.sip_headers.export(outfile, level, namespace_, name_='sip_headers', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('called_uri', node)
        if value is not None and 'called_uri' not in already_processed:
            already_processed.add('called_uri')
            self.called_uri = value
        value = find_attr_value_('caller_uri', node)
        if value is not None and 'caller_uri' not in already_processed:
            already_processed.add('caller_uri')
            self.caller_uri = value
        value = find_attr_value_('caller_display_name', node)
        if value is not None and 'caller_display_name' not in already_processed:
            already_processed.add('caller_display_name')
            self.caller_display_name = value
        value = find_attr_value_('cpa', node)
        if value is not None and 'cpa' not in already_processed:
            already_processed.add('cpa')
            self.cpa = value
            self.validate_boolean_type(self.cpa)    # validate type boolean_type
        value = find_attr_value_('cpa_profile', node)
        if value is not None and 'cpa_profile' not in already_processed:
            already_processed.add('cpa_profile')
            self.cpa_profile = value
        value = find_attr_value_('codec_profile', node)
        if value is not None and 'codec_profile' not in already_processed:
            already_processed.add('codec_profile')
            self.codec_profile = value
        value = find_attr_value_('timeout', node)
        if value is not None and 'timeout' not in already_processed:
            already_processed.add('timeout')
            self.timeout = value
            self.validate_time_value(self.timeout)    # validate type time_value
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
        value = find_attr_value_('answer_ack_mode', node)
        if value is not None and 'answer_ack_mode' not in already_processed:
            already_processed.add('answer_ack_mode')
            self.answer_ack_mode = value
            self.validate_ack_mode_option(self.answer_ack_mode)    # validate type ack_mode_option
        value = find_attr_value_('prack_mode', node)
        if value is not None and 'prack_mode' not in already_processed:
            already_processed.add('prack_mode')
            self.prack_mode = value
            self.validate_ack_mode_option(self.prack_mode)    # validate type ack_mode_option
        value = find_attr_value_('prack_level', node)
        if value is not None and 'prack_level' not in already_processed:
            already_processed.add('prack_level')
            self.prack_level = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sip_headers':
            obj_ = sip_headers.factory()
            obj_.build(child_)
            self.sip_headers = obj_
            obj_.original_tagname_ = 'sip_headers'
# end class dial


class send_info(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, content_type=None, content=None, enable_info_ack='no', content_element=None):
        self.original_tagname_ = None
        self.content_type = _cast(None, content_type)
        self.content = _cast(None, content)
        self.enable_info_ack = _cast(None, enable_info_ack)
        if content_element is None:
            self.content_element = []
        else:
            self.content_element = content_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, send_info)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if send_info.subclass:
            return send_info.subclass(*args_, **kwargs_)
        else:
            return send_info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content_element(self): return self.content_element
    def set_content_element(self, content_element): self.content_element = content_element
    def add_content_element(self, value): self.content_element.append(value)
    def insert_content_element_at(self, index, value): self.content_element.insert(index, value)
    def replace_content_element_at(self, index, value): self.content_element[index] = value
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_enable_info_ack(self): return self.enable_info_ack
    def set_enable_info_ack(self, enable_info_ack): self.enable_info_ack = enable_info_ack
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.content_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='send_info', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('send_info')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='send_info')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='send_info', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='send_info'):
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_type), input_name='content_type')), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
        if self.enable_info_ack != "no" and 'enable_info_ack' not in already_processed:
            already_processed.add('enable_info_ack')
            outfile.write(' enable_info_ack=%s' % (quote_attrib(self.enable_info_ack), ))
    def exportChildren(self, outfile, level, namespace_='', name_='send_info', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_element_ in self.content_element:
            content_element_.export(outfile, level, namespace_, name_='content_element', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
        value = find_attr_value_('enable_info_ack', node)
        if value is not None and 'enable_info_ack' not in already_processed:
            already_processed.add('enable_info_ack')
            self.enable_info_ack = value
            self.validate_boolean_type(self.enable_info_ack)    # validate type boolean_type
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content_element':
            obj_ = content_element.factory()
            obj_.build(child_)
            self.content_element.append(obj_)
            obj_.original_tagname_ = 'content_element'
# end class send_info


class send_hangup_ack(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, content_type=None, content=None):
        self.original_tagname_ = None
        self.content_type = _cast(None, content_type)
        self.content = _cast(None, content)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, send_hangup_ack)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if send_hangup_ack.subclass:
            return send_hangup_ack.subclass(*args_, **kwargs_)
        else:
            return send_hangup_ack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='send_hangup_ack', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('send_hangup_ack')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='send_hangup_ack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='send_hangup_ack', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='send_hangup_ack'):
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_type), input_name='content_type')), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='send_hangup_ack', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class send_hangup_ack


class send_dtmf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, digits=None, duration='100ms', interval='100ms', level='-10dB', transaction_id=None):
        self.original_tagname_ = None
        self.digits = _cast(None, digits)
        self.duration = _cast(None, duration)
        self.interval = _cast(None, interval)
        self.level = _cast(None, level)
        self.transaction_id = _cast(None, transaction_id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, send_dtmf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if send_dtmf.subclass:
            return send_dtmf.subclass(*args_, **kwargs_)
        else:
            return send_dtmf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_digits(self): return self.digits
    def set_digits(self, digits): self.digits = digits
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_interval(self): return self.interval
    def set_interval(self, interval): self.interval = interval
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def validate_rfc2833_digit_value(self, value):
        # Validate type rfc2833_digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_rfc2833_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_rfc2833_digit_value_patterns_, ))
    validate_rfc2833_digit_value_patterns_ = [['^[0-9#$*a-dA-D]+$|^$']]
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_dtmf_tone_range(self, value):
        # Validate type dtmf_tone_range, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_dtmf_tone_range_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_dtmf_tone_range_patterns_, ))
    validate_dtmf_tone_range_patterns_ = [['^(0$|^(\\-)([0-9]$|^1[0-9]$|^2[0-9]$|^3[0-9]$|^40))(dB$|^db$|^DB$|^Db)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='send_dtmf', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('send_dtmf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='send_dtmf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='send_dtmf', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='send_dtmf'):
        if self.digits is not None and 'digits' not in already_processed:
            already_processed.add('digits')
            outfile.write(' digits=%s' % (quote_attrib(self.digits), ))
        if self.duration != "100ms" and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (quote_attrib(self.duration), ))
        if self.interval != "100ms" and 'interval' not in already_processed:
            already_processed.add('interval')
            outfile.write(' interval=%s' % (quote_attrib(self.interval), ))
        if self.level != "-10dB" and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='send_dtmf', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('digits', node)
        if value is not None and 'digits' not in already_processed:
            already_processed.add('digits')
            self.digits = value
            self.validate_rfc2833_digit_value(self.digits)    # validate type rfc2833_digit_value
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_time_value(self.duration)    # validate type time_value
        value = find_attr_value_('interval', node)
        if value is not None and 'interval' not in already_processed:
            already_processed.add('interval')
            self.interval = value
            self.validate_time_value(self.interval)    # validate type time_value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
            self.validate_dtmf_tone_range(self.level)    # validate type dtmf_tone_range
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class send_dtmf


class get_call_info(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, local_sdp=None, remote_sdp=None, media=None, audio=None, video=None, uri=None, caller_uri=None, called_uri=None, application_id=None, local_seqno=None, remote_seqno=None, sip_headers=None):
        self.original_tagname_ = None
        self.local_sdp = _cast(None, local_sdp)
        self.remote_sdp = _cast(None, remote_sdp)
        self.media = _cast(None, media)
        self.audio = _cast(None, audio)
        self.video = _cast(None, video)
        self.uri = _cast(None, uri)
        self.caller_uri = _cast(None, caller_uri)
        self.called_uri = _cast(None, called_uri)
        self.application_id = _cast(None, application_id)
        self.local_seqno = _cast(None, local_seqno)
        self.remote_seqno = _cast(None, remote_seqno)
        self.sip_headers = sip_headers
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, get_call_info)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if get_call_info.subclass:
            return get_call_info.subclass(*args_, **kwargs_)
        else:
            return get_call_info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sip_headers(self): return self.sip_headers
    def set_sip_headers(self, sip_headers): self.sip_headers = sip_headers
    def get_local_sdp(self): return self.local_sdp
    def set_local_sdp(self, local_sdp): self.local_sdp = local_sdp
    def get_remote_sdp(self): return self.remote_sdp
    def set_remote_sdp(self, remote_sdp): self.remote_sdp = remote_sdp
    def get_media(self): return self.media
    def set_media(self, media): self.media = media
    def get_audio(self): return self.audio
    def set_audio(self, audio): self.audio = audio
    def get_video(self): return self.video
    def set_video(self, video): self.video = video
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_caller_uri(self): return self.caller_uri
    def set_caller_uri(self, caller_uri): self.caller_uri = caller_uri
    def get_called_uri(self): return self.called_uri
    def set_called_uri(self, called_uri): self.called_uri = called_uri
    def get_application_id(self): return self.application_id
    def set_application_id(self, application_id): self.application_id = application_id
    def get_local_seqno(self): return self.local_seqno
    def set_local_seqno(self, local_seqno): self.local_seqno = local_seqno
    def get_remote_seqno(self): return self.remote_seqno
    def set_remote_seqno(self, remote_seqno): self.remote_seqno = remote_seqno
    def validate_media_type(self, value):
        # Validate type media_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio', 'video', 'audiovideo', 'message', 'image', 'unknown', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_type' % {"value" : value.encode("utf-8")} )
    def validate_media_direction(self, value):
        # Validate type media_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inactive', 'sendonly', 'recvonly', 'sendrecv']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_direction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.sip_headers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='get_call_info', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('get_call_info')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='get_call_info')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='get_call_info', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='get_call_info'):
        if self.local_sdp is not None and 'local_sdp' not in already_processed:
            already_processed.add('local_sdp')
            outfile.write(' local_sdp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.local_sdp), input_name='local_sdp')), ))
        if self.remote_sdp is not None and 'remote_sdp' not in already_processed:
            already_processed.add('remote_sdp')
            outfile.write(' remote_sdp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.remote_sdp), input_name='remote_sdp')), ))
        if self.media is not None and 'media' not in already_processed:
            already_processed.add('media')
            outfile.write(' media=%s' % (quote_attrib(self.media), ))
        if self.audio is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            outfile.write(' audio=%s' % (quote_attrib(self.audio), ))
        if self.video is not None and 'video' not in already_processed:
            already_processed.add('video')
            outfile.write(' video=%s' % (quote_attrib(self.video), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
        if self.caller_uri is not None and 'caller_uri' not in already_processed:
            already_processed.add('caller_uri')
            outfile.write(' caller_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caller_uri), input_name='caller_uri')), ))
        if self.called_uri is not None and 'called_uri' not in already_processed:
            already_processed.add('called_uri')
            outfile.write(' called_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.called_uri), input_name='called_uri')), ))
        if self.application_id is not None and 'application_id' not in already_processed:
            already_processed.add('application_id')
            outfile.write(' application_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.application_id), input_name='application_id')), ))
        if self.local_seqno is not None and 'local_seqno' not in already_processed:
            already_processed.add('local_seqno')
            outfile.write(' local_seqno=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.local_seqno), input_name='local_seqno')), ))
        if self.remote_seqno is not None and 'remote_seqno' not in already_processed:
            already_processed.add('remote_seqno')
            outfile.write(' remote_seqno=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.remote_seqno), input_name='remote_seqno')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='get_call_info', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sip_headers is not None:
            self.sip_headers.export(outfile, level, namespace_, name_='sip_headers', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('local_sdp', node)
        if value is not None and 'local_sdp' not in already_processed:
            already_processed.add('local_sdp')
            self.local_sdp = value
        value = find_attr_value_('remote_sdp', node)
        if value is not None and 'remote_sdp' not in already_processed:
            already_processed.add('remote_sdp')
            self.remote_sdp = value
        value = find_attr_value_('media', node)
        if value is not None and 'media' not in already_processed:
            already_processed.add('media')
            self.media = value
            self.validate_media_type(self.media)    # validate type media_type
        value = find_attr_value_('audio', node)
        if value is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            self.audio = value
            self.validate_media_direction(self.audio)    # validate type media_direction
        value = find_attr_value_('video', node)
        if value is not None and 'video' not in already_processed:
            already_processed.add('video')
            self.video = value
            self.validate_media_direction(self.video)    # validate type media_direction
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('caller_uri', node)
        if value is not None and 'caller_uri' not in already_processed:
            already_processed.add('caller_uri')
            self.caller_uri = value
        value = find_attr_value_('called_uri', node)
        if value is not None and 'called_uri' not in already_processed:
            already_processed.add('called_uri')
            self.called_uri = value
        value = find_attr_value_('application_id', node)
        if value is not None and 'application_id' not in already_processed:
            already_processed.add('application_id')
            self.application_id = value
        value = find_attr_value_('local_seqno', node)
        if value is not None and 'local_seqno' not in already_processed:
            already_processed.add('local_seqno')
            self.local_seqno = value
        value = find_attr_value_('remote_seqno', node)
        if value is not None and 'remote_seqno' not in already_processed:
            already_processed.add('remote_seqno')
            self.remote_seqno = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sip_headers':
            obj_ = sip_headers.factory()
            obj_.build(child_)
            self.sip_headers = obj_
            obj_.original_tagname_ = 'sip_headers'
# end class get_call_info


class add_ice_candidate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mline=None, mid=None, candidate=None):
        self.original_tagname_ = None
        self.mline = _cast(None, mline)
        self.mid = _cast(None, mid)
        self.candidate = _cast(None, candidate)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, add_ice_candidate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if add_ice_candidate.subclass:
            return add_ice_candidate.subclass(*args_, **kwargs_)
        else:
            return add_ice_candidate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mline(self): return self.mline
    def set_mline(self, mline): self.mline = mline
    def get_mid(self): return self.mid
    def set_mid(self, mid): self.mid = mid
    def get_candidate(self): return self.candidate
    def set_candidate(self, candidate): self.candidate = candidate
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='add_ice_candidate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('add_ice_candidate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='add_ice_candidate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='add_ice_candidate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='add_ice_candidate'):
        if self.mline is not None and 'mline' not in already_processed:
            already_processed.add('mline')
            outfile.write(' mline=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mline), input_name='mline')), ))
        if self.mid is not None and 'mid' not in already_processed:
            already_processed.add('mid')
            outfile.write(' mid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mid), input_name='mid')), ))
        if self.candidate is not None and 'candidate' not in already_processed:
            already_processed.add('candidate')
            outfile.write(' candidate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.candidate), input_name='candidate')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='add_ice_candidate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mline', node)
        if value is not None and 'mline' not in already_processed:
            already_processed.add('mline')
            self.mline = value
        value = find_attr_value_('mid', node)
        if value is not None and 'mid' not in already_processed:
            already_processed.add('mid')
            self.mid = value
        value = find_attr_value_('candidate', node)
        if value is not None and 'candidate' not in already_processed:
            already_processed.add('candidate')
            self.candidate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class add_ice_candidate


class send_message(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caller_uri=None, called_uri=None, uri=None, content_type=None, content=None, mode='signalling', report=None, msg_multipart_type=None, transaction_id=None, content_element=None, msg_payload=None, sip_headers=None):
        self.original_tagname_ = None
        self.caller_uri = _cast(None, caller_uri)
        self.called_uri = _cast(None, called_uri)
        self.uri = _cast(None, uri)
        self.content_type = _cast(None, content_type)
        self.content = _cast(None, content)
        self.mode = _cast(None, mode)
        self.report = _cast(None, report)
        self.msg_multipart_type = _cast(None, msg_multipart_type)
        self.transaction_id = _cast(None, transaction_id)
        if content_element is None:
            self.content_element = []
        else:
            self.content_element = content_element
        if msg_payload is None:
            self.msg_payload = []
        else:
            self.msg_payload = msg_payload
        self.sip_headers = sip_headers
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, send_message)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if send_message.subclass:
            return send_message.subclass(*args_, **kwargs_)
        else:
            return send_message(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content_element(self): return self.content_element
    def set_content_element(self, content_element): self.content_element = content_element
    def add_content_element(self, value): self.content_element.append(value)
    def insert_content_element_at(self, index, value): self.content_element.insert(index, value)
    def replace_content_element_at(self, index, value): self.content_element[index] = value
    def get_msg_payload(self): return self.msg_payload
    def set_msg_payload(self, msg_payload): self.msg_payload = msg_payload
    def add_msg_payload(self, value): self.msg_payload.append(value)
    def insert_msg_payload_at(self, index, value): self.msg_payload.insert(index, value)
    def replace_msg_payload_at(self, index, value): self.msg_payload[index] = value
    def get_sip_headers(self): return self.sip_headers
    def set_sip_headers(self, sip_headers): self.sip_headers = sip_headers
    def get_caller_uri(self): return self.caller_uri
    def set_caller_uri(self, caller_uri): self.caller_uri = caller_uri
    def get_called_uri(self): return self.called_uri
    def set_called_uri(self, called_uri): self.called_uri = called_uri
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_report(self): return self.report
    def set_report(self, report): self.report = report
    def get_msg_multipart_type(self): return self.msg_multipart_type
    def set_msg_multipart_type(self, msg_multipart_type): self.msg_multipart_type = msg_multipart_type
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def hasContent_(self):
        if (
            self.content_element or
            self.msg_payload or
            self.sip_headers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='send_message', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('send_message')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='send_message')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='send_message', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='send_message'):
        if self.caller_uri is not None and 'caller_uri' not in already_processed:
            already_processed.add('caller_uri')
            outfile.write(' caller_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caller_uri), input_name='caller_uri')), ))
        if self.called_uri is not None and 'called_uri' not in already_processed:
            already_processed.add('called_uri')
            outfile.write(' called_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.called_uri), input_name='called_uri')), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_type), input_name='content_type')), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
        if self.mode != "signalling" and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mode), input_name='mode')), ))
        if self.report is not None and 'report' not in already_processed:
            already_processed.add('report')
            outfile.write(' report=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.report), input_name='report')), ))
        if self.msg_multipart_type is not None and 'msg_multipart_type' not in already_processed:
            already_processed.add('msg_multipart_type')
            outfile.write(' msg_multipart_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.msg_multipart_type), input_name='msg_multipart_type')), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='send_message', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_element_ in self.content_element:
            content_element_.export(outfile, level, namespace_, name_='content_element', pretty_print=pretty_print)
        for msg_payload_ in self.msg_payload:
            msg_payload_.export(outfile, level, namespace_, name_='msg_payload', pretty_print=pretty_print)
        if self.sip_headers is not None:
            self.sip_headers.export(outfile, level, namespace_, name_='sip_headers', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caller_uri', node)
        if value is not None and 'caller_uri' not in already_processed:
            already_processed.add('caller_uri')
            self.caller_uri = value
        value = find_attr_value_('called_uri', node)
        if value is not None and 'called_uri' not in already_processed:
            already_processed.add('called_uri')
            self.called_uri = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('report', node)
        if value is not None and 'report' not in already_processed:
            already_processed.add('report')
            self.report = value
        value = find_attr_value_('msg_multipart_type', node)
        if value is not None and 'msg_multipart_type' not in already_processed:
            already_processed.add('msg_multipart_type')
            self.msg_multipart_type = value
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content_element':
            obj_ = content_element.factory()
            obj_.build(child_)
            self.content_element.append(obj_)
            obj_.original_tagname_ = 'content_element'
        elif nodeName_ == 'msg_payload':
            obj_ = msg_payload.factory()
            obj_.build(child_)
            self.msg_payload.append(obj_)
            obj_.original_tagname_ = 'msg_payload'
        elif nodeName_ == 'sip_headers':
            obj_ = sip_headers.factory()
            obj_.build(child_)
            self.sip_headers = obj_
            obj_.original_tagname_ = 'sip_headers'
# end class send_message


class send_info_ack(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, content_type=None, content=None, content_element=None):
        self.original_tagname_ = None
        self.content_type = _cast(None, content_type)
        self.content = _cast(None, content)
        if content_element is None:
            self.content_element = []
        else:
            self.content_element = content_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, send_info_ack)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if send_info_ack.subclass:
            return send_info_ack.subclass(*args_, **kwargs_)
        else:
            return send_info_ack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content_element(self): return self.content_element
    def set_content_element(self, content_element): self.content_element = content_element
    def add_content_element(self, value): self.content_element.append(value)
    def insert_content_element_at(self, index, value): self.content_element.insert(index, value)
    def replace_content_element_at(self, index, value): self.content_element[index] = value
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def hasContent_(self):
        if (
            self.content_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='send_info_ack', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('send_info_ack')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='send_info_ack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='send_info_ack', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='send_info_ack'):
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_type), input_name='content_type')), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='send_info_ack', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_element_ in self.content_element:
            content_element_.export(outfile, level, namespace_, name_='content_element', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content_element':
            obj_ = content_element.factory()
            obj_.build(child_)
            self.content_element.append(obj_)
            obj_.original_tagname_ = 'content_element'
# end class send_info_ack


class send_event(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, events=None, duration='100ms', interval='100ms', level='-10dB', transaction_id=None):
        self.original_tagname_ = None
        self.events = _cast(None, events)
        self.duration = _cast(None, duration)
        self.interval = _cast(None, interval)
        self.level = _cast(None, level)
        self.transaction_id = _cast(None, transaction_id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, send_event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if send_event.subclass:
            return send_event.subclass(*args_, **kwargs_)
        else:
            return send_event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_events(self): return self.events
    def set_events(self, events): self.events = events
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_interval(self): return self.interval
    def set_interval(self, interval): self.interval = interval
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def validate_rfc2833_digit_value(self, value):
        # Validate type rfc2833_digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_rfc2833_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_rfc2833_digit_value_patterns_, ))
    validate_rfc2833_digit_value_patterns_ = [['^[0-9#$*a-dA-D]+$|^$']]
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_dtmf_tone_range(self, value):
        # Validate type dtmf_tone_range, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_dtmf_tone_range_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_dtmf_tone_range_patterns_, ))
    validate_dtmf_tone_range_patterns_ = [['^(0$|^(\\-)([0-9]$|^1[0-9]$|^2[0-9]$|^3[0-9]$|^40))(dB$|^db$|^DB$|^Db)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='send_event', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('send_event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='send_event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='send_event', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='send_event'):
        if self.events is not None and 'events' not in already_processed:
            already_processed.add('events')
            outfile.write(' events=%s' % (quote_attrib(self.events), ))
        if self.duration != "100ms" and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (quote_attrib(self.duration), ))
        if self.interval != "100ms" and 'interval' not in already_processed:
            already_processed.add('interval')
            outfile.write(' interval=%s' % (quote_attrib(self.interval), ))
        if self.level != "-10dB" and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='send_event', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('events', node)
        if value is not None and 'events' not in already_processed:
            already_processed.add('events')
            self.events = value
            self.validate_rfc2833_digit_value(self.events)    # validate type rfc2833_digit_value
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_time_value(self.duration)    # validate type time_value
        value = find_attr_value_('interval', node)
        if value is not None and 'interval' not in already_processed:
            already_processed.add('interval')
            self.interval = value
            self.validate_time_value(self.interval)    # validate type time_value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
            self.validate_dtmf_tone_range(self.level)    # validate type dtmf_tone_range
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class send_event


class send_prack(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, send_prack)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if send_prack.subclass:
            return send_prack.subclass(*args_, **kwargs_)
        else:
            return send_prack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='send_prack', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('send_prack')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='send_prack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='send_prack', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='send_prack'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='send_prack', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class send_prack


class send_prack_ack(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, send_prack_ack)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if send_prack_ack.subclass:
            return send_prack_ack.subclass(*args_, **kwargs_)
        else:
            return send_prack_ack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='send_prack_ack', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('send_prack_ack')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='send_prack_ack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='send_prack_ack', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='send_prack_ack'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='send_prack_ack', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class send_prack_ack


class send_answer_ack(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, send_answer_ack)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if send_answer_ack.subclass:
            return send_answer_ack.subclass(*args_, **kwargs_)
        else:
            return send_answer_ack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='send_answer_ack', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('send_answer_ack')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='send_answer_ack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='send_answer_ack', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='send_answer_ack'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='send_answer_ack', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class send_answer_ack


class cpa_operation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, action=None, cpa_profile=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.cpa_profile = _cast(None, cpa_profile)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cpa_operation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cpa_operation.subclass:
            return cpa_operation.subclass(*args_, **kwargs_)
        else:
            return cpa_operation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_cpa_profile(self): return self.cpa_profile
    def set_cpa_profile(self, cpa_profile): self.cpa_profile = cpa_profile
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cpa_operation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpa_operation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cpa_operation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cpa_operation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cpa_operation'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.action), input_name='action')), ))
        if self.cpa_profile is not None and 'cpa_profile' not in already_processed:
            already_processed.add('cpa_profile')
            outfile.write(' cpa_profile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cpa_profile), input_name='cpa_profile')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cpa_operation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
        value = find_attr_value_('cpa_profile', node)
        if value is not None and 'cpa_profile' not in already_processed:
            already_processed.add('cpa_profile')
            self.cpa_profile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cpa_operation


class call_action(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, play=None, record=None, update_play=None, playcollect=None, playrecord=None, overlay=None, stop=None, join=None, unjoin=None, add_party=None, update_party=None, remove_party=None, send_dtmf=None, send_info=None, send_info_ack=None, transfer=None, redirect=None, hangup=None, get_call_info=None, add_ice_candidate=None, send_message=None, send_hangup_ack=None, get_last_action=None, get_last_event=None, send_event=None, dial=None, send_prack=None, send_prack_ack=None, send_answer_ack=None, multi_record=None, update_multi_record=None, cpa_operation=None):
        self.original_tagname_ = None
        self.play = play
        self.record = record
        self.update_play = update_play
        self.playcollect = playcollect
        self.playrecord = playrecord
        self.overlay = overlay
        self.stop = stop
        self.join = join
        self.unjoin = unjoin
        self.add_party = add_party
        self.update_party = update_party
        self.remove_party = remove_party
        self.send_dtmf = send_dtmf
        self.send_info = send_info
        self.send_info_ack = send_info_ack
        self.transfer = transfer
        self.redirect = redirect
        self.hangup = hangup
        self.get_call_info = get_call_info
        self.add_ice_candidate = add_ice_candidate
        self.send_message = send_message
        self.send_hangup_ack = send_hangup_ack
        self.get_last_action = get_last_action
        self.get_last_event = get_last_event
        self.send_event = send_event
        self.dial = dial
        self.send_prack = send_prack
        self.send_prack_ack = send_prack_ack
        self.send_answer_ack = send_answer_ack
        self.multi_record = multi_record
        self.update_multi_record = update_multi_record
        self.cpa_operation = cpa_operation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, call_action)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if call_action.subclass:
            return call_action.subclass(*args_, **kwargs_)
        else:
            return call_action(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_play(self): return self.play
    def set_play(self, play): self.play = play
    def get_record(self): return self.record
    def set_record(self, record): self.record = record
    def get_update_play(self): return self.update_play
    def set_update_play(self, update_play): self.update_play = update_play
    def get_playcollect(self): return self.playcollect
    def set_playcollect(self, playcollect): self.playcollect = playcollect
    def get_playrecord(self): return self.playrecord
    def set_playrecord(self, playrecord): self.playrecord = playrecord
    def get_overlay(self): return self.overlay
    def set_overlay(self, overlay): self.overlay = overlay
    def get_stop(self): return self.stop
    def set_stop(self, stop): self.stop = stop
    def get_join(self): return self.join
    def set_join(self, join): self.join = join
    def get_unjoin(self): return self.unjoin
    def set_unjoin(self, unjoin): self.unjoin = unjoin
    def get_add_party(self): return self.add_party
    def set_add_party(self, add_party): self.add_party = add_party
    def get_update_party(self): return self.update_party
    def set_update_party(self, update_party): self.update_party = update_party
    def get_remove_party(self): return self.remove_party
    def set_remove_party(self, remove_party): self.remove_party = remove_party
    def get_send_dtmf(self): return self.send_dtmf
    def set_send_dtmf(self, send_dtmf): self.send_dtmf = send_dtmf
    def get_send_info(self): return self.send_info
    def set_send_info(self, send_info): self.send_info = send_info
    def get_send_info_ack(self): return self.send_info_ack
    def set_send_info_ack(self, send_info_ack): self.send_info_ack = send_info_ack
    def get_transfer(self): return self.transfer
    def set_transfer(self, transfer): self.transfer = transfer
    def get_redirect(self): return self.redirect
    def set_redirect(self, redirect): self.redirect = redirect
    def get_hangup(self): return self.hangup
    def set_hangup(self, hangup): self.hangup = hangup
    def get_get_call_info(self): return self.get_call_info
    def set_get_call_info(self, get_call_info): self.get_call_info = get_call_info
    def get_add_ice_candidate(self): return self.add_ice_candidate
    def set_add_ice_candidate(self, add_ice_candidate): self.add_ice_candidate = add_ice_candidate
    def get_send_message(self): return self.send_message
    def set_send_message(self, send_message): self.send_message = send_message
    def get_send_hangup_ack(self): return self.send_hangup_ack
    def set_send_hangup_ack(self, send_hangup_ack): self.send_hangup_ack = send_hangup_ack
    def get_get_last_action(self): return self.get_last_action
    def set_get_last_action(self, get_last_action): self.get_last_action = get_last_action
    def get_get_last_event(self): return self.get_last_event
    def set_get_last_event(self, get_last_event): self.get_last_event = get_last_event
    def get_send_event(self): return self.send_event
    def set_send_event(self, send_event): self.send_event = send_event
    def get_dial(self): return self.dial
    def set_dial(self, dial): self.dial = dial
    def get_send_prack(self): return self.send_prack
    def set_send_prack(self, send_prack): self.send_prack = send_prack
    def get_send_prack_ack(self): return self.send_prack_ack
    def set_send_prack_ack(self, send_prack_ack): self.send_prack_ack = send_prack_ack
    def get_send_answer_ack(self): return self.send_answer_ack
    def set_send_answer_ack(self, send_answer_ack): self.send_answer_ack = send_answer_ack
    def get_multi_record(self): return self.multi_record
    def set_multi_record(self, multi_record): self.multi_record = multi_record
    def get_update_multi_record(self): return self.update_multi_record
    def set_update_multi_record(self, update_multi_record): self.update_multi_record = update_multi_record
    def get_cpa_operation(self): return self.cpa_operation
    def set_cpa_operation(self, cpa_operation): self.cpa_operation = cpa_operation
    def hasContent_(self):
        if (
            self.play is not None or
            self.record is not None or
            self.update_play is not None or
            self.playcollect is not None or
            self.playrecord is not None or
            self.overlay is not None or
            self.stop is not None or
            self.join is not None or
            self.unjoin is not None or
            self.add_party is not None or
            self.update_party is not None or
            self.remove_party is not None or
            self.send_dtmf is not None or
            self.send_info is not None or
            self.send_info_ack is not None or
            self.transfer is not None or
            self.redirect is not None or
            self.hangup is not None or
            self.get_call_info is not None or
            self.add_ice_candidate is not None or
            self.send_message is not None or
            self.send_hangup_ack is not None or
            self.get_last_action is not None or
            self.get_last_event is not None or
            self.send_event is not None or
            self.dial is not None or
            self.send_prack is not None or
            self.send_prack_ack is not None or
            self.send_answer_ack is not None or
            self.multi_record is not None or
            self.update_multi_record is not None or
            self.cpa_operation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='call_action', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('call_action')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='call_action')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='call_action', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='call_action'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='call_action', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.play is not None:
            self.play.export(outfile, level, namespace_, name_='play', pretty_print=pretty_print)
        if self.record is not None:
            self.record.export(outfile, level, namespace_, name_='record', pretty_print=pretty_print)
        if self.update_play is not None:
            self.update_play.export(outfile, level, namespace_, name_='update_play', pretty_print=pretty_print)
        if self.playcollect is not None:
            self.playcollect.export(outfile, level, namespace_, name_='playcollect', pretty_print=pretty_print)
        if self.playrecord is not None:
            self.playrecord.export(outfile, level, namespace_, name_='playrecord', pretty_print=pretty_print)
        if self.overlay is not None:
            self.overlay.export(outfile, level, namespace_, name_='overlay', pretty_print=pretty_print)
        if self.stop is not None:
            self.stop.export(outfile, level, namespace_, name_='stop', pretty_print=pretty_print)
        if self.join is not None:
            self.join.export(outfile, level, namespace_, name_='join', pretty_print=pretty_print)
        if self.unjoin is not None:
            self.unjoin.export(outfile, level, namespace_, name_='unjoin', pretty_print=pretty_print)
        if self.add_party is not None:
            self.add_party.export(outfile, level, namespace_, name_='add_party', pretty_print=pretty_print)
        if self.update_party is not None:
            self.update_party.export(outfile, level, namespace_, name_='update_party', pretty_print=pretty_print)
        if self.remove_party is not None:
            self.remove_party.export(outfile, level, namespace_, name_='remove_party', pretty_print=pretty_print)
        if self.send_dtmf is not None:
            self.send_dtmf.export(outfile, level, namespace_, name_='send_dtmf', pretty_print=pretty_print)
        if self.send_info is not None:
            self.send_info.export(outfile, level, namespace_, name_='send_info', pretty_print=pretty_print)
        if self.send_info_ack is not None:
            self.send_info_ack.export(outfile, level, namespace_, name_='send_info_ack', pretty_print=pretty_print)
        if self.transfer is not None:
            self.transfer.export(outfile, level, namespace_, name_='transfer', pretty_print=pretty_print)
        if self.redirect is not None:
            self.redirect.export(outfile, level, namespace_, name_='redirect', pretty_print=pretty_print)
        if self.hangup is not None:
            self.hangup.export(outfile, level, namespace_, name_='hangup', pretty_print=pretty_print)
        if self.get_call_info is not None:
            self.get_call_info.export(outfile, level, namespace_, name_='get_call_info', pretty_print=pretty_print)
        if self.add_ice_candidate is not None:
            self.add_ice_candidate.export(outfile, level, namespace_, name_='add_ice_candidate', pretty_print=pretty_print)
        if self.send_message is not None:
            self.send_message.export(outfile, level, namespace_, name_='send_message', pretty_print=pretty_print)
        if self.send_hangup_ack is not None:
            self.send_hangup_ack.export(outfile, level, namespace_, name_='send_hangup_ack', pretty_print=pretty_print)
        if self.get_last_action is not None:
            self.get_last_action.export(outfile, level, namespace_, name_='get_last_action', pretty_print=pretty_print)
        if self.get_last_event is not None:
            self.get_last_event.export(outfile, level, namespace_, name_='get_last_event', pretty_print=pretty_print)
        if self.send_event is not None:
            self.send_event.export(outfile, level, namespace_, name_='send_event', pretty_print=pretty_print)
        if self.dial is not None:
            self.dial.export(outfile, level, namespace_, name_='dial', pretty_print=pretty_print)
        if self.send_prack is not None:
            self.send_prack.export(outfile, level, namespace_, name_='send_prack', pretty_print=pretty_print)
        if self.send_prack_ack is not None:
            self.send_prack_ack.export(outfile, level, namespace_, name_='send_prack_ack', pretty_print=pretty_print)
        if self.send_answer_ack is not None:
            self.send_answer_ack.export(outfile, level, namespace_, name_='send_answer_ack', pretty_print=pretty_print)
        if self.multi_record is not None:
            self.multi_record.export(outfile, level, namespace_, name_='multi_record', pretty_print=pretty_print)
        if self.update_multi_record is not None:
            self.update_multi_record.export(outfile, level, namespace_, name_='update_multi_record', pretty_print=pretty_print)
        if self.cpa_operation is not None:
            self.cpa_operation.export(outfile, level, namespace_, name_='cpa_operation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'play':
            obj_ = play.factory()
            obj_.build(child_)
            self.play = obj_
            obj_.original_tagname_ = 'play'
        elif nodeName_ == 'record':
            obj_ = record.factory()
            obj_.build(child_)
            self.record = obj_
            obj_.original_tagname_ = 'record'
        elif nodeName_ == 'update_play':
            obj_ = update_play.factory()
            obj_.build(child_)
            self.update_play = obj_
            obj_.original_tagname_ = 'update_play'
        elif nodeName_ == 'playcollect':
            obj_ = playcollect.factory()
            obj_.build(child_)
            self.playcollect = obj_
            obj_.original_tagname_ = 'playcollect'
        elif nodeName_ == 'playrecord':
            obj_ = playrecord.factory()
            obj_.build(child_)
            self.playrecord = obj_
            obj_.original_tagname_ = 'playrecord'
        elif nodeName_ == 'overlay':
            obj_ = overlay.factory()
            obj_.build(child_)
            self.overlay = obj_
            obj_.original_tagname_ = 'overlay'
        elif nodeName_ == 'stop':
            obj_ = stop.factory()
            obj_.build(child_)
            self.stop = obj_
            obj_.original_tagname_ = 'stop'
        elif nodeName_ == 'join':
            obj_ = join.factory()
            obj_.build(child_)
            self.join = obj_
            obj_.original_tagname_ = 'join'
        elif nodeName_ == 'unjoin':
            obj_ = unjoin.factory()
            obj_.build(child_)
            self.unjoin = obj_
            obj_.original_tagname_ = 'unjoin'
        elif nodeName_ == 'add_party':
            obj_ = add_party.factory()
            obj_.build(child_)
            self.add_party = obj_
            obj_.original_tagname_ = 'add_party'
        elif nodeName_ == 'update_party':
            obj_ = update_party.factory()
            obj_.build(child_)
            self.update_party = obj_
            obj_.original_tagname_ = 'update_party'
        elif nodeName_ == 'remove_party':
            obj_ = remove_party.factory()
            obj_.build(child_)
            self.remove_party = obj_
            obj_.original_tagname_ = 'remove_party'
        elif nodeName_ == 'send_dtmf':
            obj_ = send_dtmf.factory()
            obj_.build(child_)
            self.send_dtmf = obj_
            obj_.original_tagname_ = 'send_dtmf'
        elif nodeName_ == 'send_info':
            obj_ = send_info.factory()
            obj_.build(child_)
            self.send_info = obj_
            obj_.original_tagname_ = 'send_info'
        elif nodeName_ == 'send_info_ack':
            obj_ = send_info_ack.factory()
            obj_.build(child_)
            self.send_info_ack = obj_
            obj_.original_tagname_ = 'send_info_ack'
        elif nodeName_ == 'transfer':
            obj_ = transfer.factory()
            obj_.build(child_)
            self.transfer = obj_
            obj_.original_tagname_ = 'transfer'
        elif nodeName_ == 'redirect':
            obj_ = redirect.factory()
            obj_.build(child_)
            self.redirect = obj_
            obj_.original_tagname_ = 'redirect'
        elif nodeName_ == 'hangup':
            obj_ = hangup.factory()
            obj_.build(child_)
            self.hangup = obj_
            obj_.original_tagname_ = 'hangup'
        elif nodeName_ == 'get_call_info':
            obj_ = get_call_info.factory()
            obj_.build(child_)
            self.get_call_info = obj_
            obj_.original_tagname_ = 'get_call_info'
        elif nodeName_ == 'add_ice_candidate':
            obj_ = add_ice_candidate.factory()
            obj_.build(child_)
            self.add_ice_candidate = obj_
            obj_.original_tagname_ = 'add_ice_candidate'
        elif nodeName_ == 'send_message':
            obj_ = send_message.factory()
            obj_.build(child_)
            self.send_message = obj_
            obj_.original_tagname_ = 'send_message'
        elif nodeName_ == 'send_hangup_ack':
            obj_ = send_hangup_ack.factory()
            obj_.build(child_)
            self.send_hangup_ack = obj_
            obj_.original_tagname_ = 'send_hangup_ack'
        elif nodeName_ == 'get_last_action':
            obj_ = get_last_action.factory()
            obj_.build(child_)
            self.get_last_action = obj_
            obj_.original_tagname_ = 'get_last_action'
        elif nodeName_ == 'get_last_event':
            obj_ = get_last_event.factory()
            obj_.build(child_)
            self.get_last_event = obj_
            obj_.original_tagname_ = 'get_last_event'
        elif nodeName_ == 'send_event':
            obj_ = send_event.factory()
            obj_.build(child_)
            self.send_event = obj_
            obj_.original_tagname_ = 'send_event'
        elif nodeName_ == 'dial':
            obj_ = dial.factory()
            obj_.build(child_)
            self.dial = obj_
            obj_.original_tagname_ = 'dial'
        elif nodeName_ == 'send_prack':
            obj_ = send_prack.factory()
            obj_.build(child_)
            self.send_prack = obj_
            obj_.original_tagname_ = 'send_prack'
        elif nodeName_ == 'send_prack_ack':
            obj_ = send_prack_ack.factory()
            obj_.build(child_)
            self.send_prack_ack = obj_
            obj_.original_tagname_ = 'send_prack_ack'
        elif nodeName_ == 'send_answer_ack':
            obj_ = send_answer_ack.factory()
            obj_.build(child_)
            self.send_answer_ack = obj_
            obj_.original_tagname_ = 'send_answer_ack'
        elif nodeName_ == 'multi_record':
            obj_ = multi_record.factory()
            obj_.build(child_)
            self.multi_record = obj_
            obj_.original_tagname_ = 'multi_record'
        elif nodeName_ == 'update_multi_record':
            obj_ = update_multi_record.factory()
            obj_.build(child_)
            self.update_multi_record = obj_
            obj_.original_tagname_ = 'update_multi_record'
        elif nodeName_ == 'cpa_operation':
            obj_ = cpa_operation.factory()
            obj_.build(child_)
            self.cpa_operation = obj_
            obj_.original_tagname_ = 'cpa_operation'
# end class call_action


class conf_action(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, play=None, record=None, update_play=None, stop=None, get_last_action=None, get_last_event=None, send_dtmf=None, playcollect=None, playrecord=None, send_event=None, multi_record=None, update_multi_record=None):
        self.original_tagname_ = None
        self.play = play
        self.record = record
        self.update_play = update_play
        self.stop = stop
        self.get_last_action = get_last_action
        self.get_last_event = get_last_event
        self.send_dtmf = send_dtmf
        self.playcollect = playcollect
        self.playrecord = playrecord
        self.send_event = send_event
        self.multi_record = multi_record
        self.update_multi_record = update_multi_record
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, conf_action)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if conf_action.subclass:
            return conf_action.subclass(*args_, **kwargs_)
        else:
            return conf_action(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_play(self): return self.play
    def set_play(self, play): self.play = play
    def get_record(self): return self.record
    def set_record(self, record): self.record = record
    def get_update_play(self): return self.update_play
    def set_update_play(self, update_play): self.update_play = update_play
    def get_stop(self): return self.stop
    def set_stop(self, stop): self.stop = stop
    def get_get_last_action(self): return self.get_last_action
    def set_get_last_action(self, get_last_action): self.get_last_action = get_last_action
    def get_get_last_event(self): return self.get_last_event
    def set_get_last_event(self, get_last_event): self.get_last_event = get_last_event
    def get_send_dtmf(self): return self.send_dtmf
    def set_send_dtmf(self, send_dtmf): self.send_dtmf = send_dtmf
    def get_playcollect(self): return self.playcollect
    def set_playcollect(self, playcollect): self.playcollect = playcollect
    def get_playrecord(self): return self.playrecord
    def set_playrecord(self, playrecord): self.playrecord = playrecord
    def get_send_event(self): return self.send_event
    def set_send_event(self, send_event): self.send_event = send_event
    def get_multi_record(self): return self.multi_record
    def set_multi_record(self, multi_record): self.multi_record = multi_record
    def get_update_multi_record(self): return self.update_multi_record
    def set_update_multi_record(self, update_multi_record): self.update_multi_record = update_multi_record
    def hasContent_(self):
        if (
            self.play is not None or
            self.record is not None or
            self.update_play is not None or
            self.stop is not None or
            self.get_last_action is not None or
            self.get_last_event is not None or
            self.send_dtmf is not None or
            self.playcollect is not None or
            self.playrecord is not None or
            self.send_event is not None or
            self.multi_record is not None or
            self.update_multi_record is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conf_action', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('conf_action')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conf_action')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conf_action', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conf_action'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='conf_action', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.play is not None:
            self.play.export(outfile, level, namespace_, name_='play', pretty_print=pretty_print)
        if self.record is not None:
            self.record.export(outfile, level, namespace_, name_='record', pretty_print=pretty_print)
        if self.update_play is not None:
            self.update_play.export(outfile, level, namespace_, name_='update_play', pretty_print=pretty_print)
        if self.stop is not None:
            self.stop.export(outfile, level, namespace_, name_='stop', pretty_print=pretty_print)
        if self.get_last_action is not None:
            self.get_last_action.export(outfile, level, namespace_, name_='get_last_action', pretty_print=pretty_print)
        if self.get_last_event is not None:
            self.get_last_event.export(outfile, level, namespace_, name_='get_last_event', pretty_print=pretty_print)
        if self.send_dtmf is not None:
            self.send_dtmf.export(outfile, level, namespace_, name_='send_dtmf', pretty_print=pretty_print)
        if self.playcollect is not None:
            self.playcollect.export(outfile, level, namespace_, name_='playcollect', pretty_print=pretty_print)
        if self.playrecord is not None:
            self.playrecord.export(outfile, level, namespace_, name_='playrecord', pretty_print=pretty_print)
        if self.send_event is not None:
            self.send_event.export(outfile, level, namespace_, name_='send_event', pretty_print=pretty_print)
        if self.multi_record is not None:
            self.multi_record.export(outfile, level, namespace_, name_='multi_record', pretty_print=pretty_print)
        if self.update_multi_record is not None:
            self.update_multi_record.export(outfile, level, namespace_, name_='update_multi_record', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'play':
            obj_ = play.factory()
            obj_.build(child_)
            self.play = obj_
            obj_.original_tagname_ = 'play'
        elif nodeName_ == 'record':
            obj_ = record.factory()
            obj_.build(child_)
            self.record = obj_
            obj_.original_tagname_ = 'record'
        elif nodeName_ == 'update_play':
            obj_ = update_play.factory()
            obj_.build(child_)
            self.update_play = obj_
            obj_.original_tagname_ = 'update_play'
        elif nodeName_ == 'stop':
            obj_ = stop.factory()
            obj_.build(child_)
            self.stop = obj_
            obj_.original_tagname_ = 'stop'
        elif nodeName_ == 'get_last_action':
            obj_ = get_last_action.factory()
            obj_.build(child_)
            self.get_last_action = obj_
            obj_.original_tagname_ = 'get_last_action'
        elif nodeName_ == 'get_last_event':
            obj_ = get_last_event.factory()
            obj_.build(child_)
            self.get_last_event = obj_
            obj_.original_tagname_ = 'get_last_event'
        elif nodeName_ == 'send_dtmf':
            obj_ = send_dtmf.factory()
            obj_.build(child_)
            self.send_dtmf = obj_
            obj_.original_tagname_ = 'send_dtmf'
        elif nodeName_ == 'playcollect':
            obj_ = playcollect.factory()
            obj_.build(child_)
            self.playcollect = obj_
            obj_.original_tagname_ = 'playcollect'
        elif nodeName_ == 'playrecord':
            obj_ = playrecord.factory()
            obj_.build(child_)
            self.playrecord = obj_
            obj_.original_tagname_ = 'playrecord'
        elif nodeName_ == 'send_event':
            obj_ = send_event.factory()
            obj_.build(child_)
            self.send_event = obj_
            obj_.original_tagname_ = 'send_event'
        elif nodeName_ == 'multi_record':
            obj_ = multi_record.factory()
            obj_.build(child_)
            self.multi_record = obj_
            obj_.original_tagname_ = 'multi_record'
        elif nodeName_ == 'update_multi_record':
            obj_ = update_multi_record.factory()
            obj_.build(child_)
            self.update_multi_record = obj_
            obj_.original_tagname_ = 'update_multi_record'
# end class conf_action


class speak(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, call_id=None, barge='yes', locale='en-US', content=None, content_type=None, transaction_id=None, param=None):
        self.original_tagname_ = None
        self.call_id = _cast(None, call_id)
        self.barge = _cast(None, barge)
        self.locale = _cast(None, locale)
        self.content = _cast(None, content)
        self.content_type = _cast(None, content_type)
        self.transaction_id = _cast(None, transaction_id)
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, speak)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if speak.subclass:
            return speak.subclass(*args_, **kwargs_)
        else:
            return speak(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def add_param(self, value): self.param.append(value)
    def insert_param_at(self, index, value): self.param.insert(index, value)
    def replace_param_at(self, index, value): self.param[index] = value
    def get_call_id(self): return self.call_id
    def set_call_id(self, call_id): self.call_id = call_id
    def get_barge(self): return self.barge
    def set_barge(self, barge): self.barge = barge
    def get_locale(self): return self.locale
    def set_locale(self, locale): self.locale = locale
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.param
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='speak', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('speak')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='speak')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='speak', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='speak'):
        if self.call_id is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            outfile.write(' call_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.call_id), input_name='call_id')), ))
        if self.barge != "yes" and 'barge' not in already_processed:
            already_processed.add('barge')
            outfile.write(' barge=%s' % (quote_attrib(self.barge), ))
        if self.locale != "en-US" and 'locale' not in already_processed:
            already_processed.add('locale')
            outfile.write(' locale=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.locale), input_name='locale')), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_type), input_name='content_type')), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='speak', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('call_id', node)
        if value is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            self.call_id = value
        value = find_attr_value_('barge', node)
        if value is not None and 'barge' not in already_processed:
            already_processed.add('barge')
            self.barge = value
            self.validate_boolean_type(self.barge)    # validate type boolean_type
        value = find_attr_value_('locale', node)
        if value is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            self.locale = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
# end class speak


class recognize(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, call_id=None, grammar=None, grammar_type=None, grammar_id=None, timeout='infinite', transaction_id=None, param=None):
        self.original_tagname_ = None
        self.call_id = _cast(None, call_id)
        self.grammar = _cast(None, grammar)
        self.grammar_type = _cast(None, grammar_type)
        self.grammar_id = _cast(None, grammar_id)
        self.timeout = _cast(None, timeout)
        self.transaction_id = _cast(None, transaction_id)
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recognize)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recognize.subclass:
            return recognize.subclass(*args_, **kwargs_)
        else:
            return recognize(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def add_param(self, value): self.param.append(value)
    def insert_param_at(self, index, value): self.param.insert(index, value)
    def replace_param_at(self, index, value): self.param[index] = value
    def get_call_id(self): return self.call_id
    def set_call_id(self, call_id): self.call_id = call_id
    def get_grammar(self): return self.grammar
    def set_grammar(self, grammar): self.grammar = grammar
    def get_grammar_type(self): return self.grammar_type
    def set_grammar_type(self, grammar_type): self.grammar_type = grammar_type
    def get_grammar_id(self): return self.grammar_id
    def set_grammar_id(self, grammar_id): self.grammar_id = grammar_id
    def get_timeout(self): return self.timeout
    def set_timeout(self, timeout): self.timeout = timeout
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def hasContent_(self):
        if (
            self.param
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recognize', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('recognize')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recognize')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recognize', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recognize'):
        if self.call_id is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            outfile.write(' call_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.call_id), input_name='call_id')), ))
        if self.grammar is not None and 'grammar' not in already_processed:
            already_processed.add('grammar')
            outfile.write(' grammar=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.grammar), input_name='grammar')), ))
        if self.grammar_type is not None and 'grammar_type' not in already_processed:
            already_processed.add('grammar_type')
            outfile.write(' grammar_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.grammar_type), input_name='grammar_type')), ))
        if self.grammar_id is not None and 'grammar_id' not in already_processed:
            already_processed.add('grammar_id')
            outfile.write(' grammar_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.grammar_id), input_name='grammar_id')), ))
        if self.timeout != "infinite" and 'timeout' not in already_processed:
            already_processed.add('timeout')
            outfile.write(' timeout=%s' % (quote_attrib(self.timeout), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='recognize', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('call_id', node)
        if value is not None and 'call_id' not in already_processed:
            already_processed.add('call_id')
            self.call_id = value
        value = find_attr_value_('grammar', node)
        if value is not None and 'grammar' not in already_processed:
            already_processed.add('grammar')
            self.grammar = value
        value = find_attr_value_('grammar_type', node)
        if value is not None and 'grammar_type' not in already_processed:
            already_processed.add('grammar_type')
            self.grammar_type = value
        value = find_attr_value_('grammar_id', node)
        if value is not None and 'grammar_id' not in already_processed:
            already_processed.add('grammar_id')
            self.grammar_id = value
        value = find_attr_value_('timeout', node)
        if value is not None and 'timeout' not in already_processed:
            already_processed.add('timeout')
            self.timeout = value
            self.validate_time_value(self.timeout)    # validate type time_value
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
# end class recognize


class set_asr_param(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, param=None):
        self.original_tagname_ = None
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, set_asr_param)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if set_asr_param.subclass:
            return set_asr_param.subclass(*args_, **kwargs_)
        else:
            return set_asr_param(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def add_param(self, value): self.param.append(value)
    def insert_param_at(self, index, value): self.param.insert(index, value)
    def replace_param_at(self, index, value): self.param[index] = value
    def hasContent_(self):
        if (
            self.param
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='set-asr-param', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('set-asr-param')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='set-asr-param')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='set-asr-param', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='set-asr-param'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='set-asr-param', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
# end class set_asr_param


class get_asr_param(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, param=None):
        self.original_tagname_ = None
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, get_asr_param)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if get_asr_param.subclass:
            return get_asr_param.subclass(*args_, **kwargs_)
        else:
            return get_asr_param(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def add_param(self, value): self.param.append(value)
    def insert_param_at(self, index, value): self.param.insert(index, value)
    def replace_param_at(self, index, value): self.param[index] = value
    def hasContent_(self):
        if (
            self.param
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='get-asr-param', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('get-asr-param')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='get-asr-param')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='get-asr-param', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='get-asr-param'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='get-asr-param', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
# end class get_asr_param


class set_tts_param(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, param=None):
        self.original_tagname_ = None
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, set_tts_param)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if set_tts_param.subclass:
            return set_tts_param.subclass(*args_, **kwargs_)
        else:
            return set_tts_param(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def add_param(self, value): self.param.append(value)
    def insert_param_at(self, index, value): self.param.insert(index, value)
    def replace_param_at(self, index, value): self.param[index] = value
    def hasContent_(self):
        if (
            self.param
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='set-tts-param', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('set-tts-param')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='set-tts-param')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='set-tts-param', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='set-tts-param'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='set-tts-param', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
# end class set_tts_param


class define_grammar(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, grammar=None, grammar_type=None, grammar_id=None):
        self.original_tagname_ = None
        self.grammar = _cast(None, grammar)
        self.grammar_type = _cast(None, grammar_type)
        self.grammar_id = _cast(None, grammar_id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, define_grammar)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if define_grammar.subclass:
            return define_grammar.subclass(*args_, **kwargs_)
        else:
            return define_grammar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_grammar(self): return self.grammar
    def set_grammar(self, grammar): self.grammar = grammar
    def get_grammar_type(self): return self.grammar_type
    def set_grammar_type(self, grammar_type): self.grammar_type = grammar_type
    def get_grammar_id(self): return self.grammar_id
    def set_grammar_id(self, grammar_id): self.grammar_id = grammar_id
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='define-grammar', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('define-grammar')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='define-grammar')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='define-grammar', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='define-grammar'):
        if self.grammar is not None and 'grammar' not in already_processed:
            already_processed.add('grammar')
            outfile.write(' grammar=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.grammar), input_name='grammar')), ))
        if self.grammar_type is not None and 'grammar_type' not in already_processed:
            already_processed.add('grammar_type')
            outfile.write(' grammar_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.grammar_type), input_name='grammar_type')), ))
        if self.grammar_id is not None and 'grammar_id' not in already_processed:
            already_processed.add('grammar_id')
            outfile.write(' grammar_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.grammar_id), input_name='grammar_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='define-grammar', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('grammar', node)
        if value is not None and 'grammar' not in already_processed:
            already_processed.add('grammar')
            self.grammar = value
        value = find_attr_value_('grammar_type', node)
        if value is not None and 'grammar_type' not in already_processed:
            already_processed.add('grammar_type')
            self.grammar_type = value
        value = find_attr_value_('grammar_id', node)
        if value is not None and 'grammar_id' not in already_processed:
            already_processed.add('grammar_id')
            self.grammar_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class define_grammar


class get_tts_param(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, param=None):
        self.original_tagname_ = None
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, get_tts_param)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if get_tts_param.subclass:
            return get_tts_param.subclass(*args_, **kwargs_)
        else:
            return get_tts_param(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def add_param(self, value): self.param.append(value)
    def insert_param_at(self, index, value): self.param.insert(index, value)
    def replace_param_at(self, index, value): self.param[index] = value
    def hasContent_(self):
        if (
            self.param
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='get-tts-param', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('get-tts-param')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='get-tts-param')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='get-tts-param', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='get-tts-param'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='get-tts-param', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
# end class get_tts_param


class mrcp_update_action(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, action=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mrcp_update_action)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mrcp_update_action.subclass:
            return mrcp_update_action.subclass(*args_, **kwargs_)
        else:
            return mrcp_update_action(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_mrcp_action_option(self, value):
        # Validate type mrcp_action_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['stop-speak', 'stop-recognize', 'pause', 'resume', 'barge', 'start-input-timers']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on mrcp_action_option' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mrcp-update-action', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mrcp-update-action')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mrcp-update-action')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mrcp-update-action', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mrcp-update-action'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mrcp-update-action', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
            self.validate_mrcp_action_option(self.action)    # validate type mrcp_action_option
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mrcp_update_action


class mrcp_action(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, speak=None, recognize=None, mrcp_update_action=None, set_asr_param=None, get_asr_param=None, set_tts_param=None, get_tts_param=None, define_grammar=None, get_last_action=None, get_last_event=None):
        self.original_tagname_ = None
        self.speak = speak
        self.recognize = recognize
        self.mrcp_update_action = mrcp_update_action
        self.set_asr_param = set_asr_param
        self.get_asr_param = get_asr_param
        self.set_tts_param = set_tts_param
        self.get_tts_param = get_tts_param
        self.define_grammar = define_grammar
        self.get_last_action = get_last_action
        self.get_last_event = get_last_event
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mrcp_action)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mrcp_action.subclass:
            return mrcp_action.subclass(*args_, **kwargs_)
        else:
            return mrcp_action(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_speak(self): return self.speak
    def set_speak(self, speak): self.speak = speak
    def get_recognize(self): return self.recognize
    def set_recognize(self, recognize): self.recognize = recognize
    def get_mrcp_update_action(self): return self.mrcp_update_action
    def set_mrcp_update_action(self, mrcp_update_action): self.mrcp_update_action = mrcp_update_action
    def get_set_asr_param(self): return self.set_asr_param
    def set_set_asr_param(self, set_asr_param): self.set_asr_param = set_asr_param
    def get_get_asr_param(self): return self.get_asr_param
    def set_get_asr_param(self, get_asr_param): self.get_asr_param = get_asr_param
    def get_set_tts_param(self): return self.set_tts_param
    def set_set_tts_param(self, set_tts_param): self.set_tts_param = set_tts_param
    def get_get_tts_param(self): return self.get_tts_param
    def set_get_tts_param(self, get_tts_param): self.get_tts_param = get_tts_param
    def get_define_grammar(self): return self.define_grammar
    def set_define_grammar(self, define_grammar): self.define_grammar = define_grammar
    def get_get_last_action(self): return self.get_last_action
    def set_get_last_action(self, get_last_action): self.get_last_action = get_last_action
    def get_get_last_event(self): return self.get_last_event
    def set_get_last_event(self, get_last_event): self.get_last_event = get_last_event
    def hasContent_(self):
        if (
            self.speak is not None or
            self.recognize is not None or
            self.mrcp_update_action is not None or
            self.set_asr_param is not None or
            self.get_asr_param is not None or
            self.set_tts_param is not None or
            self.get_tts_param is not None or
            self.define_grammar is not None or
            self.get_last_action is not None or
            self.get_last_event is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mrcp_action', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mrcp_action')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mrcp_action')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mrcp_action', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mrcp_action'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='mrcp_action', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.speak is not None:
            self.speak.export(outfile, level, namespace_, name_='speak', pretty_print=pretty_print)
        if self.recognize is not None:
            self.recognize.export(outfile, level, namespace_, name_='recognize', pretty_print=pretty_print)
        if self.mrcp_update_action is not None:
            self.mrcp_update_action.export(outfile, level, namespace_, name_='mrcp-update-action', pretty_print=pretty_print)
        if self.set_asr_param is not None:
            self.set_asr_param.export(outfile, level, namespace_, name_='set-asr-param', pretty_print=pretty_print)
        if self.get_asr_param is not None:
            self.get_asr_param.export(outfile, level, namespace_, name_='get-asr-param', pretty_print=pretty_print)
        if self.set_tts_param is not None:
            self.set_tts_param.export(outfile, level, namespace_, name_='set-tts-param', pretty_print=pretty_print)
        if self.get_tts_param is not None:
            self.get_tts_param.export(outfile, level, namespace_, name_='get-tts-param', pretty_print=pretty_print)
        if self.define_grammar is not None:
            self.define_grammar.export(outfile, level, namespace_, name_='define-grammar', pretty_print=pretty_print)
        if self.get_last_action is not None:
            self.get_last_action.export(outfile, level, namespace_, name_='get_last_action', pretty_print=pretty_print)
        if self.get_last_event is not None:
            self.get_last_event.export(outfile, level, namespace_, name_='get_last_event', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'speak':
            obj_ = speak.factory()
            obj_.build(child_)
            self.speak = obj_
            obj_.original_tagname_ = 'speak'
        elif nodeName_ == 'recognize':
            obj_ = recognize.factory()
            obj_.build(child_)
            self.recognize = obj_
            obj_.original_tagname_ = 'recognize'
        elif nodeName_ == 'mrcp-update-action':
            obj_ = mrcp_update_action.factory()
            obj_.build(child_)
            self.mrcp_update_action = obj_
            obj_.original_tagname_ = 'mrcp-update-action'
        elif nodeName_ == 'set-asr-param':
            obj_ = set_asr_param.factory()
            obj_.build(child_)
            self.set_asr_param = obj_
            obj_.original_tagname_ = 'set-asr-param'
        elif nodeName_ == 'get-asr-param':
            obj_ = get_asr_param.factory()
            obj_.build(child_)
            self.get_asr_param = obj_
            obj_.original_tagname_ = 'get-asr-param'
        elif nodeName_ == 'set-tts-param':
            obj_ = set_tts_param.factory()
            obj_.build(child_)
            self.set_tts_param = obj_
            obj_.original_tagname_ = 'set-tts-param'
        elif nodeName_ == 'get-tts-param':
            obj_ = get_tts_param.factory()
            obj_.build(child_)
            self.get_tts_param = obj_
            obj_.original_tagname_ = 'get-tts-param'
        elif nodeName_ == 'define-grammar':
            obj_ = define_grammar.factory()
            obj_.build(child_)
            self.define_grammar = obj_
            obj_.original_tagname_ = 'define-grammar'
        elif nodeName_ == 'get_last_action':
            obj_ = get_last_action.factory()
            obj_.build(child_)
            self.get_last_action = obj_
            obj_.original_tagname_ = 'get_last_action'
        elif nodeName_ == 'get_last_event':
            obj_ = get_last_event.factory()
            obj_.build(child_)
            self.get_last_event = obj_
            obj_.original_tagname_ = 'get_last_event'
# end class mrcp_action


class overlay(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uri=None, duration='infinite', direction='send', transaction_id=None):
        self.original_tagname_ = None
        self.uri = _cast(None, uri)
        self.duration = _cast(None, duration)
        self.direction = _cast(None, direction)
        self.transaction_id = _cast(None, transaction_id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, overlay)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if overlay.subclass:
            return overlay.subclass(*args_, **kwargs_)
        else:
            return overlay(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='overlay', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('overlay')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='overlay')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='overlay', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='overlay'):
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
        if self.duration != "infinite" and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (quote_attrib(self.duration), ))
        if self.direction != "send" and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='overlay', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_time_value(self.duration)    # validate type time_value
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class overlay


class event_data(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, event_data)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if event_data.subclass:
            return event_data.subclass(*args_, **kwargs_)
        else:
            return event_data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='event_data', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('event_data')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='event_data')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='event_data', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='event_data'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='event_data', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class event_data


class sip_headers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, raw_sip_headers=None, param=None):
        self.original_tagname_ = None
        self.raw_sip_headers = _cast(None, raw_sip_headers)
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sip_headers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sip_headers.subclass:
            return sip_headers.subclass(*args_, **kwargs_)
        else:
            return sip_headers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def add_param(self, value): self.param.append(value)
    def insert_param_at(self, index, value): self.param.insert(index, value)
    def replace_param_at(self, index, value): self.param[index] = value
    def get_raw_sip_headers(self): return self.raw_sip_headers
    def set_raw_sip_headers(self, raw_sip_headers): self.raw_sip_headers = raw_sip_headers
    def hasContent_(self):
        if (
            self.param
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sip_headers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sip_headers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sip_headers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sip_headers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sip_headers'):
        if self.raw_sip_headers is not None and 'raw_sip_headers' not in already_processed:
            already_processed.add('raw_sip_headers')
            outfile.write(' raw_sip_headers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.raw_sip_headers), input_name='raw_sip_headers')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sip_headers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('raw_sip_headers', node)
        if value is not None and 'raw_sip_headers' not in already_processed:
            already_processed.add('raw_sip_headers')
            self.raw_sip_headers = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
# end class sip_headers


class event(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, resource_type=None, resource_id=None, event_data=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.resource_type = _cast(None, resource_type)
        self.resource_id = _cast(None, resource_id)
        if event_data is None:
            self.event_data = []
        else:
            self.event_data = event_data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if event.subclass:
            return event.subclass(*args_, **kwargs_)
        else:
            return event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_event_data(self): return self.event_data
    def set_event_data(self, event_data): self.event_data = event_data
    def add_event_data(self, value): self.event_data.append(value)
    def insert_event_data_at(self, index, value): self.event_data.insert(index, value)
    def replace_event_data_at(self, index, value): self.event_data[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_resource_type(self): return self.resource_type
    def set_resource_type(self, resource_type): self.resource_type = resource_type
    def get_resource_id(self): return self.resource_id
    def set_resource_id(self, resource_id): self.resource_id = resource_id
    def validate_event_type(self, value):
        # Validate type event_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['end_play', 'end_record', 'end_playcollect', 'end_playrecord', 'end_overlay', 'end_dtmf', 'keepalive', 'incoming', 'ringing', 'connected', 'hangup', 'info', 'dtmf', 'tone', 'any', 'end_speak', 'start_of_input', 'end_recognize', 'answered', 'accepted', 'updated', 'active_talker', 'alarm', 'prack', 'conf_overlay_expired', 'message', 'end_send_message', 'stream', 'speech_marker', 'start_play', 'end_event', 'progress', 'prack_ack', 'status', 'info_ack', 'media_started', 'end_transfer', 'cpa']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on event_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.event_data
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='event', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='event'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.resource_type is not None and 'resource_type' not in already_processed:
            already_processed.add('resource_type')
            outfile.write(' resource_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.resource_type), input_name='resource_type')), ))
        if self.resource_id is not None and 'resource_id' not in already_processed:
            already_processed.add('resource_id')
            outfile.write(' resource_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.resource_id), input_name='resource_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for event_data_ in self.event_data:
            event_data_.export(outfile, level, namespace_, name_='event_data', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_event_type(self.type_)    # validate type event_type
        value = find_attr_value_('resource_type', node)
        if value is not None and 'resource_type' not in already_processed:
            already_processed.add('resource_type')
            self.resource_type = value
        value = find_attr_value_('resource_id', node)
        if value is not None and 'resource_id' not in already_processed:
            already_processed.add('resource_id')
            self.resource_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'event_data':
            obj_ = event_data.factory()
            obj_.build(child_)
            self.event_data.append(obj_)
            obj_.original_tagname_ = 'event_data'
# end class event


class stop(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, transaction_id=None):
        self.original_tagname_ = None
        self.transaction_id = _cast(None, transaction_id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stop)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stop.subclass:
            return stop.subclass(*args_, **kwargs_)
        else:
            return stop(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='stop', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stop')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stop')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='stop', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='stop'):
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='stop', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stop


class play_source(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, location=None, base_audio_uri=None, audio_base_uri=None, audio_uri=None, audio_type=None, audio_rate=None, base_video_uri=None, video_base_uri=None, video_uri=None, video_type=None, audio_track_id=None):
        self.original_tagname_ = None
        self.location = _cast(None, location)
        self.base_audio_uri = _cast(None, base_audio_uri)
        self.audio_base_uri = _cast(None, audio_base_uri)
        self.audio_uri = _cast(None, audio_uri)
        self.audio_type = _cast(None, audio_type)
        self.audio_rate = _cast(None, audio_rate)
        self.base_video_uri = _cast(None, base_video_uri)
        self.video_base_uri = _cast(None, video_base_uri)
        self.video_uri = _cast(None, video_uri)
        self.video_type = _cast(None, video_type)
        self.audio_track_id = _cast(None, audio_track_id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, play_source)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if play_source.subclass:
            return play_source.subclass(*args_, **kwargs_)
        else:
            return play_source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_base_audio_uri(self): return self.base_audio_uri
    def set_base_audio_uri(self, base_audio_uri): self.base_audio_uri = base_audio_uri
    def get_audio_base_uri(self): return self.audio_base_uri
    def set_audio_base_uri(self, audio_base_uri): self.audio_base_uri = audio_base_uri
    def get_audio_uri(self): return self.audio_uri
    def set_audio_uri(self, audio_uri): self.audio_uri = audio_uri
    def get_audio_type(self): return self.audio_type
    def set_audio_type(self, audio_type): self.audio_type = audio_type
    def get_audio_rate(self): return self.audio_rate
    def set_audio_rate(self, audio_rate): self.audio_rate = audio_rate
    def get_base_video_uri(self): return self.base_video_uri
    def set_base_video_uri(self, base_video_uri): self.base_video_uri = base_video_uri
    def get_video_base_uri(self): return self.video_base_uri
    def set_video_base_uri(self, video_base_uri): self.video_base_uri = video_base_uri
    def get_video_uri(self): return self.video_uri
    def set_video_uri(self, video_uri): self.video_uri = video_uri
    def get_video_type(self): return self.video_type
    def set_video_type(self, video_type): self.video_type = video_type
    def get_audio_track_id(self): return self.audio_track_id
    def set_audio_track_id(self, audio_track_id): self.audio_track_id = audio_track_id
    def validate_audio_type_option(self, value):
        # Validate type audio_type_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio/x-wav', 'audio/basic', 'audio/x-alaw-basic', 'audio/L8', 'audio/L16', 'audio/x-aud', 'audio/AMR', 'audio/AMR-WB', 'audio/3gpp', 'audio/mp4', 'audio/mkv', 'audio/webm', 'audio/evs', 'text/uri-list']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on audio_type_option' % {"value" : value.encode("utf-8")} )
    def validate_audio_rate_option(self, value):
        # Validate type audio_rate_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['8000', '11025', '16000']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on audio_rate_option' % {"value" : value.encode("utf-8")} )
    def validate_video_type_option(self, value):
        # Validate type video_type_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['video/x-vid', 'video/3gpp', 'image/jpeg', 'video/mp4', 'video/mkv', 'video/webm']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on video_type_option' % {"value" : value.encode("utf-8")} )
    def validate_digit_value(self, value):
        # Validate type digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_digit_value_patterns_, ))
    validate_digit_value_patterns_ = [['^[0-9#*]+$|^$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='play_source', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('play_source')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='play_source')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='play_source', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='play_source'):
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            outfile.write(' location=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.location), input_name='location')), ))
        if self.base_audio_uri is not None and 'base_audio_uri' not in already_processed:
            already_processed.add('base_audio_uri')
            outfile.write(' base_audio_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.base_audio_uri), input_name='base_audio_uri')), ))
        if self.audio_base_uri is not None and 'audio_base_uri' not in already_processed:
            already_processed.add('audio_base_uri')
            outfile.write(' audio_base_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.audio_base_uri), input_name='audio_base_uri')), ))
        if self.audio_uri is not None and 'audio_uri' not in already_processed:
            already_processed.add('audio_uri')
            outfile.write(' audio_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.audio_uri), input_name='audio_uri')), ))
        if self.audio_type is not None and 'audio_type' not in already_processed:
            already_processed.add('audio_type')
            outfile.write(' audio_type=%s' % (quote_attrib(self.audio_type), ))
        if self.audio_rate is not None and 'audio_rate' not in already_processed:
            already_processed.add('audio_rate')
            outfile.write(' audio_rate=%s' % (quote_attrib(self.audio_rate), ))
        if self.base_video_uri is not None and 'base_video_uri' not in already_processed:
            already_processed.add('base_video_uri')
            outfile.write(' base_video_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.base_video_uri), input_name='base_video_uri')), ))
        if self.video_base_uri is not None and 'video_base_uri' not in already_processed:
            already_processed.add('video_base_uri')
            outfile.write(' video_base_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.video_base_uri), input_name='video_base_uri')), ))
        if self.video_uri is not None and 'video_uri' not in already_processed:
            already_processed.add('video_uri')
            outfile.write(' video_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.video_uri), input_name='video_uri')), ))
        if self.video_type is not None and 'video_type' not in already_processed:
            already_processed.add('video_type')
            outfile.write(' video_type=%s' % (quote_attrib(self.video_type), ))
        if self.audio_track_id is not None and 'audio_track_id' not in already_processed:
            already_processed.add('audio_track_id')
            outfile.write(' audio_track_id=%s' % (quote_attrib(self.audio_track_id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='play_source', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.add('location')
            self.location = value
        value = find_attr_value_('base_audio_uri', node)
        if value is not None and 'base_audio_uri' not in already_processed:
            already_processed.add('base_audio_uri')
            self.base_audio_uri = value
        value = find_attr_value_('audio_base_uri', node)
        if value is not None and 'audio_base_uri' not in already_processed:
            already_processed.add('audio_base_uri')
            self.audio_base_uri = value
        value = find_attr_value_('audio_uri', node)
        if value is not None and 'audio_uri' not in already_processed:
            already_processed.add('audio_uri')
            self.audio_uri = value
        value = find_attr_value_('audio_type', node)
        if value is not None and 'audio_type' not in already_processed:
            already_processed.add('audio_type')
            self.audio_type = value
            self.validate_audio_type_option(self.audio_type)    # validate type audio_type_option
        value = find_attr_value_('audio_rate', node)
        if value is not None and 'audio_rate' not in already_processed:
            already_processed.add('audio_rate')
            self.audio_rate = value
            self.validate_audio_rate_option(self.audio_rate)    # validate type audio_rate_option
        value = find_attr_value_('base_video_uri', node)
        if value is not None and 'base_video_uri' not in already_processed:
            already_processed.add('base_video_uri')
            self.base_video_uri = value
        value = find_attr_value_('video_base_uri', node)
        if value is not None and 'video_base_uri' not in already_processed:
            already_processed.add('video_base_uri')
            self.video_base_uri = value
        value = find_attr_value_('video_uri', node)
        if value is not None and 'video_uri' not in already_processed:
            already_processed.add('video_uri')
            self.video_uri = value
        value = find_attr_value_('video_type', node)
        if value is not None and 'video_type' not in already_processed:
            already_processed.add('video_type')
            self.video_type = value
            self.validate_video_type_option(self.video_type)    # validate type video_type_option
        value = find_attr_value_('audio_track_id', node)
        if value is not None and 'audio_track_id' not in already_processed:
            already_processed.add('audio_track_id')
            self.audio_track_id = value
            self.validate_digit_value(self.audio_track_id)    # validate type digit_value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class play_source


class play(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, offset='0s', repeat='0', delay='1s', skip_interval='1s', max_time='infinite', terminate_digits='#', region=None, transaction_id=None, no_cache=None, max_age=None, max_stale=None, fetch_timeout='300s', play_source=None, dvr_setting=None):
        self.original_tagname_ = None
        self.offset = _cast(None, offset)
        self.repeat = _cast(None, repeat)
        self.delay = _cast(None, delay)
        self.skip_interval = _cast(None, skip_interval)
        self.max_time = _cast(None, max_time)
        self.terminate_digits = _cast(None, terminate_digits)
        self.region = _cast(None, region)
        self.transaction_id = _cast(None, transaction_id)
        self.no_cache = _cast(None, no_cache)
        self.max_age = _cast(None, max_age)
        self.max_stale = _cast(None, max_stale)
        self.fetch_timeout = _cast(None, fetch_timeout)
        self.play_source = play_source
        self.dvr_setting = dvr_setting
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, play)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if play.subclass:
            return play.subclass(*args_, **kwargs_)
        else:
            return play(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_play_source(self): return self.play_source
    def set_play_source(self, play_source): self.play_source = play_source
    def get_dvr_setting(self): return self.dvr_setting
    def set_dvr_setting(self, dvr_setting): self.dvr_setting = dvr_setting
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def get_repeat(self): return self.repeat
    def set_repeat(self, repeat): self.repeat = repeat
    def get_delay(self): return self.delay
    def set_delay(self, delay): self.delay = delay
    def get_skip_interval(self): return self.skip_interval
    def set_skip_interval(self, skip_interval): self.skip_interval = skip_interval
    def get_max_time(self): return self.max_time
    def set_max_time(self, max_time): self.max_time = max_time
    def get_terminate_digits(self): return self.terminate_digits
    def set_terminate_digits(self, terminate_digits): self.terminate_digits = terminate_digits
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def get_no_cache(self): return self.no_cache
    def set_no_cache(self, no_cache): self.no_cache = no_cache
    def get_max_age(self): return self.max_age
    def set_max_age(self, max_age): self.max_age = max_age
    def get_max_stale(self): return self.max_stale
    def set_max_stale(self, max_stale): self.max_stale = max_stale
    def get_fetch_timeout(self): return self.fetch_timeout
    def set_fetch_timeout(self, fetch_timeout): self.fetch_timeout = fetch_timeout
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_integer_value(self, value):
        # Validate type integer_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_integer_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_integer_value_patterns_, ))
    validate_integer_value_patterns_ = [['^[0-9]+$|^infinite$']]
    def validate_digit_value(self, value):
        # Validate type digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_digit_value_patterns_, ))
    validate_digit_value_patterns_ = [['^[0-9#*]+$|^$']]
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.play_source is not None or
            self.dvr_setting is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='play', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('play')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='play')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='play', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='play'):
        if self.offset != "0s" and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset=%s' % (quote_attrib(self.offset), ))
        if self.repeat != "0" and 'repeat' not in already_processed:
            already_processed.add('repeat')
            outfile.write(' repeat=%s' % (quote_attrib(self.repeat), ))
        if self.delay != "1s" and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (quote_attrib(self.delay), ))
        if self.skip_interval != "1s" and 'skip_interval' not in already_processed:
            already_processed.add('skip_interval')
            outfile.write(' skip_interval=%s' % (quote_attrib(self.skip_interval), ))
        if self.max_time != "infinite" and 'max_time' not in already_processed:
            already_processed.add('max_time')
            outfile.write(' max_time=%s' % (quote_attrib(self.max_time), ))
        if self.terminate_digits != "#" and 'terminate_digits' not in already_processed:
            already_processed.add('terminate_digits')
            outfile.write(' terminate_digits=%s' % (quote_attrib(self.terminate_digits), ))
        if self.region is not None and 'region' not in already_processed:
            already_processed.add('region')
            outfile.write(' region=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.region), input_name='region')), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
        if self.no_cache is not None and 'no_cache' not in already_processed:
            already_processed.add('no_cache')
            outfile.write(' no_cache=%s' % (quote_attrib(self.no_cache), ))
        if self.max_age is not None and 'max_age' not in already_processed:
            already_processed.add('max_age')
            outfile.write(' max_age=%s' % (quote_attrib(self.max_age), ))
        if self.max_stale is not None and 'max_stale' not in already_processed:
            already_processed.add('max_stale')
            outfile.write(' max_stale=%s' % (quote_attrib(self.max_stale), ))
        if self.fetch_timeout != "300s" and 'fetch_timeout' not in already_processed:
            already_processed.add('fetch_timeout')
            outfile.write(' fetch_timeout=%s' % (quote_attrib(self.fetch_timeout), ))
    def exportChildren(self, outfile, level, namespace_='', name_='play', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.play_source is not None:
            self.play_source.export(outfile, level, namespace_, name_='play_source', pretty_print=pretty_print)
        if self.dvr_setting is not None:
            self.dvr_setting.export(outfile, level, namespace_, name_='dvr_setting', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = value
            self.validate_time_value(self.offset)    # validate type time_value
        value = find_attr_value_('repeat', node)
        if value is not None and 'repeat' not in already_processed:
            already_processed.add('repeat')
            self.repeat = value
            self.validate_integer_value(self.repeat)    # validate type integer_value
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_time_value(self.delay)    # validate type time_value
        value = find_attr_value_('skip_interval', node)
        if value is not None and 'skip_interval' not in already_processed:
            already_processed.add('skip_interval')
            self.skip_interval = value
            self.validate_time_value(self.skip_interval)    # validate type time_value
        value = find_attr_value_('max_time', node)
        if value is not None and 'max_time' not in already_processed:
            already_processed.add('max_time')
            self.max_time = value
            self.validate_time_value(self.max_time)    # validate type time_value
        value = find_attr_value_('terminate_digits', node)
        if value is not None and 'terminate_digits' not in already_processed:
            already_processed.add('terminate_digits')
            self.terminate_digits = value
            self.validate_digit_value(self.terminate_digits)    # validate type digit_value
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.add('region')
            self.region = value
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
        value = find_attr_value_('no_cache', node)
        if value is not None and 'no_cache' not in already_processed:
            already_processed.add('no_cache')
            self.no_cache = value
            self.validate_boolean_type(self.no_cache)    # validate type boolean_type
        value = find_attr_value_('max_age', node)
        if value is not None and 'max_age' not in already_processed:
            already_processed.add('max_age')
            self.max_age = value
            self.validate_time_value(self.max_age)    # validate type time_value
        value = find_attr_value_('max_stale', node)
        if value is not None and 'max_stale' not in already_processed:
            already_processed.add('max_stale')
            self.max_stale = value
            self.validate_time_value(self.max_stale)    # validate type time_value
        value = find_attr_value_('fetch_timeout', node)
        if value is not None and 'fetch_timeout' not in already_processed:
            already_processed.add('fetch_timeout')
            self.fetch_timeout = value
            self.validate_time_value(self.fetch_timeout)    # validate type time_value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'play_source':
            obj_ = play_source.factory()
            obj_.build(child_)
            self.play_source = obj_
            obj_.original_tagname_ = 'play_source'
        elif nodeName_ == 'dvr_setting':
            obj_ = dvr_setting.factory()
            obj_.build(child_)
            self.dvr_setting = obj_
            obj_.original_tagname_ = 'dvr_setting'
# end class play


class update_play(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dvr_action=None, region=None, transaction_id=None):
        self.original_tagname_ = None
        self.dvr_action = _cast(None, dvr_action)
        self.region = _cast(None, region)
        self.transaction_id = _cast(None, transaction_id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, update_play)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if update_play.subclass:
            return update_play.subclass(*args_, **kwargs_)
        else:
            return update_play(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dvr_action(self): return self.dvr_action
    def set_dvr_action(self, dvr_action): self.dvr_action = dvr_action
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def validate_dvr_action_option(self, value):
        # Validate type dvr_action_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['forward', 'backward', 'pause', 'resume', 'restart']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on dvr_action_option' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='update_play', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('update_play')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='update_play')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='update_play', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='update_play'):
        if self.dvr_action is not None and 'dvr_action' not in already_processed:
            already_processed.add('dvr_action')
            outfile.write(' dvr_action=%s' % (quote_attrib(self.dvr_action), ))
        if self.region is not None and 'region' not in already_processed:
            already_processed.add('region')
            outfile.write(' region=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.region), input_name='region')), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='update_play', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dvr_action', node)
        if value is not None and 'dvr_action' not in already_processed:
            already_processed.add('dvr_action')
            self.dvr_action = value
            self.validate_dvr_action_option(self.dvr_action)    # validate type dvr_action_option
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.add('region')
            self.region = value
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class update_play


class multi_record(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, terminate_digits='#', recording_audio_uri=None, recording_audio_type=None, recording_video_uri=None, recording_video_type='video/x-vid', max_silence='infinite', max_time='infinite', noinput_timeout='infinite', clamp_dtmf=None, append='no', public_key=None, transaction_id=None, recording_audio_mime_params=None, recording_video_mime_params=None, record_track=None):
        self.original_tagname_ = None
        self.terminate_digits = _cast(None, terminate_digits)
        self.recording_audio_uri = _cast(None, recording_audio_uri)
        self.recording_audio_type = _cast(None, recording_audio_type)
        self.recording_video_uri = _cast(None, recording_video_uri)
        self.recording_video_type = _cast(None, recording_video_type)
        self.max_silence = _cast(None, max_silence)
        self.max_time = _cast(None, max_time)
        self.noinput_timeout = _cast(None, noinput_timeout)
        self.clamp_dtmf = _cast(None, clamp_dtmf)
        self.append = _cast(None, append)
        self.public_key = _cast(None, public_key)
        self.transaction_id = _cast(None, transaction_id)
        self.recording_audio_mime_params = recording_audio_mime_params
        self.recording_video_mime_params = recording_video_mime_params
        self.record_track = record_track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, multi_record)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if multi_record.subclass:
            return multi_record.subclass(*args_, **kwargs_)
        else:
            return multi_record(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recording_audio_mime_params(self): return self.recording_audio_mime_params
    def set_recording_audio_mime_params(self, recording_audio_mime_params): self.recording_audio_mime_params = recording_audio_mime_params
    def get_recording_video_mime_params(self): return self.recording_video_mime_params
    def set_recording_video_mime_params(self, recording_video_mime_params): self.recording_video_mime_params = recording_video_mime_params
    def get_record_track(self): return self.record_track
    def set_record_track(self, record_track): self.record_track = record_track
    def get_terminate_digits(self): return self.terminate_digits
    def set_terminate_digits(self, terminate_digits): self.terminate_digits = terminate_digits
    def get_recording_audio_uri(self): return self.recording_audio_uri
    def set_recording_audio_uri(self, recording_audio_uri): self.recording_audio_uri = recording_audio_uri
    def get_recording_audio_type(self): return self.recording_audio_type
    def set_recording_audio_type(self, recording_audio_type): self.recording_audio_type = recording_audio_type
    def get_recording_video_uri(self): return self.recording_video_uri
    def set_recording_video_uri(self, recording_video_uri): self.recording_video_uri = recording_video_uri
    def get_recording_video_type(self): return self.recording_video_type
    def set_recording_video_type(self, recording_video_type): self.recording_video_type = recording_video_type
    def get_max_silence(self): return self.max_silence
    def set_max_silence(self, max_silence): self.max_silence = max_silence
    def get_max_time(self): return self.max_time
    def set_max_time(self, max_time): self.max_time = max_time
    def get_noinput_timeout(self): return self.noinput_timeout
    def set_noinput_timeout(self, noinput_timeout): self.noinput_timeout = noinput_timeout
    def get_clamp_dtmf(self): return self.clamp_dtmf
    def set_clamp_dtmf(self, clamp_dtmf): self.clamp_dtmf = clamp_dtmf
    def get_append(self): return self.append
    def set_append(self, append): self.append = append
    def get_public_key(self): return self.public_key
    def set_public_key(self, public_key): self.public_key = public_key
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def validate_digit_value(self, value):
        # Validate type digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_digit_value_patterns_, ))
    validate_digit_value_patterns_ = [['^[0-9#*]+$|^$']]
    def validate_audio_type_option(self, value):
        # Validate type audio_type_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio/x-wav', 'audio/basic', 'audio/x-alaw-basic', 'audio/L8', 'audio/L16', 'audio/x-aud', 'audio/AMR', 'audio/AMR-WB', 'audio/3gpp', 'audio/mp4', 'audio/mkv', 'audio/webm', 'audio/evs', 'text/uri-list']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on audio_type_option' % {"value" : value.encode("utf-8")} )
    def validate_recording_video_type_option(self, value):
        # Validate type recording_video_type_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['video/x-vid', 'video/3gpp', 'image/jpeg', 'video/mp4', 'video/mkv', 'video/webm']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on recording_video_type_option' % {"value" : value.encode("utf-8")} )
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.recording_audio_mime_params is not None or
            self.recording_video_mime_params is not None or
            self.record_track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='multi_record', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('multi_record')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='multi_record')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='multi_record', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='multi_record'):
        if self.terminate_digits != "#" and 'terminate_digits' not in already_processed:
            already_processed.add('terminate_digits')
            outfile.write(' terminate_digits=%s' % (quote_attrib(self.terminate_digits), ))
        if self.recording_audio_uri is not None and 'recording_audio_uri' not in already_processed:
            already_processed.add('recording_audio_uri')
            outfile.write(' recording_audio_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.recording_audio_uri), input_name='recording_audio_uri')), ))
        if self.recording_audio_type is not None and 'recording_audio_type' not in already_processed:
            already_processed.add('recording_audio_type')
            outfile.write(' recording_audio_type=%s' % (quote_attrib(self.recording_audio_type), ))
        if self.recording_video_uri is not None and 'recording_video_uri' not in already_processed:
            already_processed.add('recording_video_uri')
            outfile.write(' recording_video_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.recording_video_uri), input_name='recording_video_uri')), ))
        if self.recording_video_type != "video/x-vid" and 'recording_video_type' not in already_processed:
            already_processed.add('recording_video_type')
            outfile.write(' recording_video_type=%s' % (quote_attrib(self.recording_video_type), ))
        if self.max_silence != "infinite" and 'max_silence' not in already_processed:
            already_processed.add('max_silence')
            outfile.write(' max_silence=%s' % (quote_attrib(self.max_silence), ))
        if self.max_time != "infinite" and 'max_time' not in already_processed:
            already_processed.add('max_time')
            outfile.write(' max_time=%s' % (quote_attrib(self.max_time), ))
        if self.noinput_timeout != "infinite" and 'noinput_timeout' not in already_processed:
            already_processed.add('noinput_timeout')
            outfile.write(' noinput_timeout=%s' % (quote_attrib(self.noinput_timeout), ))
        if self.clamp_dtmf is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            outfile.write(' clamp_dtmf=%s' % (quote_attrib(self.clamp_dtmf), ))
        if self.append != "no" and 'append' not in already_processed:
            already_processed.add('append')
            outfile.write(' append=%s' % (quote_attrib(self.append), ))
        if self.public_key is not None and 'public_key' not in already_processed:
            already_processed.add('public_key')
            outfile.write(' public_key=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.public_key), input_name='public_key')), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='multi_record', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.recording_audio_mime_params is not None:
            self.recording_audio_mime_params.export(outfile, level, namespace_, name_='recording_audio_mime_params', pretty_print=pretty_print)
        if self.recording_video_mime_params is not None:
            self.recording_video_mime_params.export(outfile, level, namespace_, name_='recording_video_mime_params', pretty_print=pretty_print)
        if self.record_track is not None:
            self.record_track.export(outfile, level, namespace_, name_='record_track', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('terminate_digits', node)
        if value is not None and 'terminate_digits' not in already_processed:
            already_processed.add('terminate_digits')
            self.terminate_digits = value
            self.validate_digit_value(self.terminate_digits)    # validate type digit_value
        value = find_attr_value_('recording_audio_uri', node)
        if value is not None and 'recording_audio_uri' not in already_processed:
            already_processed.add('recording_audio_uri')
            self.recording_audio_uri = value
        value = find_attr_value_('recording_audio_type', node)
        if value is not None and 'recording_audio_type' not in already_processed:
            already_processed.add('recording_audio_type')
            self.recording_audio_type = value
            self.validate_audio_type_option(self.recording_audio_type)    # validate type audio_type_option
        value = find_attr_value_('recording_video_uri', node)
        if value is not None and 'recording_video_uri' not in already_processed:
            already_processed.add('recording_video_uri')
            self.recording_video_uri = value
        value = find_attr_value_('recording_video_type', node)
        if value is not None and 'recording_video_type' not in already_processed:
            already_processed.add('recording_video_type')
            self.recording_video_type = value
            self.validate_recording_video_type_option(self.recording_video_type)    # validate type recording_video_type_option
        value = find_attr_value_('max_silence', node)
        if value is not None and 'max_silence' not in already_processed:
            already_processed.add('max_silence')
            self.max_silence = value
            self.validate_time_value(self.max_silence)    # validate type time_value
        value = find_attr_value_('max_time', node)
        if value is not None and 'max_time' not in already_processed:
            already_processed.add('max_time')
            self.max_time = value
            self.validate_time_value(self.max_time)    # validate type time_value
        value = find_attr_value_('noinput_timeout', node)
        if value is not None and 'noinput_timeout' not in already_processed:
            already_processed.add('noinput_timeout')
            self.noinput_timeout = value
            self.validate_time_value(self.noinput_timeout)    # validate type time_value
        value = find_attr_value_('clamp_dtmf', node)
        if value is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            self.clamp_dtmf = value
            self.validate_boolean_type(self.clamp_dtmf)    # validate type boolean_type
        value = find_attr_value_('append', node)
        if value is not None and 'append' not in already_processed:
            already_processed.add('append')
            self.append = value
            self.validate_boolean_type(self.append)    # validate type boolean_type
        value = find_attr_value_('public_key', node)
        if value is not None and 'public_key' not in already_processed:
            already_processed.add('public_key')
            self.public_key = value
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'recording_audio_mime_params':
            obj_ = recording_audio_mime_params.factory()
            obj_.build(child_)
            self.recording_audio_mime_params = obj_
            obj_.original_tagname_ = 'recording_audio_mime_params'
        elif nodeName_ == 'recording_video_mime_params':
            obj_ = recording_video_mime_params.factory()
            obj_.build(child_)
            self.recording_video_mime_params = obj_
            obj_.original_tagname_ = 'recording_video_mime_params'
        elif nodeName_ == 'record_track':
            obj_ = record_track.factory()
            obj_.build(child_)
            self.record_track = obj_
            obj_.original_tagname_ = 'record_track'
# end class multi_record


class update_multi_record(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, transaction_id=None, id=None, track_id=None, direction=None):
        self.original_tagname_ = None
        self.transaction_id = _cast(None, transaction_id)
        self.id = _cast(None, id)
        self.track_id = _cast(None, track_id)
        self.direction = _cast(None, direction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, update_multi_record)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if update_multi_record.subclass:
            return update_multi_record.subclass(*args_, **kwargs_)
        else:
            return update_multi_record(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_track_id(self): return self.track_id
    def set_track_id(self, track_id): self.track_id = track_id
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def validate_digit_value(self, value):
        # Validate type digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_digit_value_patterns_, ))
    validate_digit_value_patterns_ = [['^[0-9#*]+$|^$']]
    def validate_record_track_direction(self, value):
        # Validate type record_track_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['send', 'recv']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on record_track_direction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='update_multi_record', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('update_multi_record')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='update_multi_record')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='update_multi_record', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='update_multi_record'):
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.track_id is not None and 'track_id' not in already_processed:
            already_processed.add('track_id')
            outfile.write(' track_id=%s' % (quote_attrib(self.track_id), ))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (quote_attrib(self.direction), ))
    def exportChildren(self, outfile, level, namespace_='', name_='update_multi_record', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('track_id', node)
        if value is not None and 'track_id' not in already_processed:
            already_processed.add('track_id')
            self.track_id = value
            self.validate_digit_value(self.track_id)    # validate type digit_value
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
            self.validate_record_track_direction(self.direction)    # validate type record_track_direction
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class update_multi_record


class record(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, terminate_digits='#', recording_uri=None, recording_audio_uri=None, recording_audio_type=None, recording_video_uri=None, recording_video_type='video/x-vid', max_silence='infinite', max_time='infinite', noinput_timeout='infinite', clamp_dtmf=None, append='no', public_key=None, transaction_id=None, recording_audio_mime_params=None, recording_video_mime_params=None):
        self.original_tagname_ = None
        self.terminate_digits = _cast(None, terminate_digits)
        self.recording_uri = _cast(None, recording_uri)
        self.recording_audio_uri = _cast(None, recording_audio_uri)
        self.recording_audio_type = _cast(None, recording_audio_type)
        self.recording_video_uri = _cast(None, recording_video_uri)
        self.recording_video_type = _cast(None, recording_video_type)
        self.max_silence = _cast(None, max_silence)
        self.max_time = _cast(None, max_time)
        self.noinput_timeout = _cast(None, noinput_timeout)
        self.clamp_dtmf = _cast(None, clamp_dtmf)
        self.append = _cast(None, append)
        self.public_key = _cast(None, public_key)
        self.transaction_id = _cast(None, transaction_id)
        self.recording_audio_mime_params = recording_audio_mime_params
        self.recording_video_mime_params = recording_video_mime_params
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, record)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if record.subclass:
            return record.subclass(*args_, **kwargs_)
        else:
            return record(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recording_audio_mime_params(self): return self.recording_audio_mime_params
    def set_recording_audio_mime_params(self, recording_audio_mime_params): self.recording_audio_mime_params = recording_audio_mime_params
    def get_recording_video_mime_params(self): return self.recording_video_mime_params
    def set_recording_video_mime_params(self, recording_video_mime_params): self.recording_video_mime_params = recording_video_mime_params
    def get_terminate_digits(self): return self.terminate_digits
    def set_terminate_digits(self, terminate_digits): self.terminate_digits = terminate_digits
    def get_recording_uri(self): return self.recording_uri
    def set_recording_uri(self, recording_uri): self.recording_uri = recording_uri
    def get_recording_audio_uri(self): return self.recording_audio_uri
    def set_recording_audio_uri(self, recording_audio_uri): self.recording_audio_uri = recording_audio_uri
    def get_recording_audio_type(self): return self.recording_audio_type
    def set_recording_audio_type(self, recording_audio_type): self.recording_audio_type = recording_audio_type
    def get_recording_video_uri(self): return self.recording_video_uri
    def set_recording_video_uri(self, recording_video_uri): self.recording_video_uri = recording_video_uri
    def get_recording_video_type(self): return self.recording_video_type
    def set_recording_video_type(self, recording_video_type): self.recording_video_type = recording_video_type
    def get_max_silence(self): return self.max_silence
    def set_max_silence(self, max_silence): self.max_silence = max_silence
    def get_max_time(self): return self.max_time
    def set_max_time(self, max_time): self.max_time = max_time
    def get_noinput_timeout(self): return self.noinput_timeout
    def set_noinput_timeout(self, noinput_timeout): self.noinput_timeout = noinput_timeout
    def get_clamp_dtmf(self): return self.clamp_dtmf
    def set_clamp_dtmf(self, clamp_dtmf): self.clamp_dtmf = clamp_dtmf
    def get_append(self): return self.append
    def set_append(self, append): self.append = append
    def get_public_key(self): return self.public_key
    def set_public_key(self, public_key): self.public_key = public_key
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def validate_digit_value(self, value):
        # Validate type digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_digit_value_patterns_, ))
    validate_digit_value_patterns_ = [['^[0-9#*]+$|^$']]
    def validate_audio_type_option(self, value):
        # Validate type audio_type_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio/x-wav', 'audio/basic', 'audio/x-alaw-basic', 'audio/L8', 'audio/L16', 'audio/x-aud', 'audio/AMR', 'audio/AMR-WB', 'audio/3gpp', 'audio/mp4', 'audio/mkv', 'audio/webm', 'audio/evs', 'text/uri-list']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on audio_type_option' % {"value" : value.encode("utf-8")} )
    def validate_recording_video_type_option(self, value):
        # Validate type recording_video_type_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['video/x-vid', 'video/3gpp', 'image/jpeg', 'video/mp4', 'video/mkv', 'video/webm']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on recording_video_type_option' % {"value" : value.encode("utf-8")} )
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.recording_audio_mime_params is not None or
            self.recording_video_mime_params is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='record', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('record')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='record')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='record', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='record'):
        if self.terminate_digits != "#" and 'terminate_digits' not in already_processed:
            already_processed.add('terminate_digits')
            outfile.write(' terminate_digits=%s' % (quote_attrib(self.terminate_digits), ))
        if self.recording_uri is not None and 'recording_uri' not in already_processed:
            already_processed.add('recording_uri')
            outfile.write(' recording_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.recording_uri), input_name='recording_uri')), ))
        if self.recording_audio_uri is not None and 'recording_audio_uri' not in already_processed:
            already_processed.add('recording_audio_uri')
            outfile.write(' recording_audio_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.recording_audio_uri), input_name='recording_audio_uri')), ))
        if self.recording_audio_type is not None and 'recording_audio_type' not in already_processed:
            already_processed.add('recording_audio_type')
            outfile.write(' recording_audio_type=%s' % (quote_attrib(self.recording_audio_type), ))
        if self.recording_video_uri is not None and 'recording_video_uri' not in already_processed:
            already_processed.add('recording_video_uri')
            outfile.write(' recording_video_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.recording_video_uri), input_name='recording_video_uri')), ))
        if self.recording_video_type != "video/x-vid" and 'recording_video_type' not in already_processed:
            already_processed.add('recording_video_type')
            outfile.write(' recording_video_type=%s' % (quote_attrib(self.recording_video_type), ))
        if self.max_silence != "infinite" and 'max_silence' not in already_processed:
            already_processed.add('max_silence')
            outfile.write(' max_silence=%s' % (quote_attrib(self.max_silence), ))
        if self.max_time != "infinite" and 'max_time' not in already_processed:
            already_processed.add('max_time')
            outfile.write(' max_time=%s' % (quote_attrib(self.max_time), ))
        if self.noinput_timeout != "infinite" and 'noinput_timeout' not in already_processed:
            already_processed.add('noinput_timeout')
            outfile.write(' noinput_timeout=%s' % (quote_attrib(self.noinput_timeout), ))
        if self.clamp_dtmf is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            outfile.write(' clamp_dtmf=%s' % (quote_attrib(self.clamp_dtmf), ))
        if self.append != "no" and 'append' not in already_processed:
            already_processed.add('append')
            outfile.write(' append=%s' % (quote_attrib(self.append), ))
        if self.public_key is not None and 'public_key' not in already_processed:
            already_processed.add('public_key')
            outfile.write(' public_key=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.public_key), input_name='public_key')), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='record', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.recording_audio_mime_params is not None:
            self.recording_audio_mime_params.export(outfile, level, namespace_, name_='recording_audio_mime_params', pretty_print=pretty_print)
        if self.recording_video_mime_params is not None:
            self.recording_video_mime_params.export(outfile, level, namespace_, name_='recording_video_mime_params', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('terminate_digits', node)
        if value is not None and 'terminate_digits' not in already_processed:
            already_processed.add('terminate_digits')
            self.terminate_digits = value
            self.validate_digit_value(self.terminate_digits)    # validate type digit_value
        value = find_attr_value_('recording_uri', node)
        if value is not None and 'recording_uri' not in already_processed:
            already_processed.add('recording_uri')
            self.recording_uri = value
        value = find_attr_value_('recording_audio_uri', node)
        if value is not None and 'recording_audio_uri' not in already_processed:
            already_processed.add('recording_audio_uri')
            self.recording_audio_uri = value
        value = find_attr_value_('recording_audio_type', node)
        if value is not None and 'recording_audio_type' not in already_processed:
            already_processed.add('recording_audio_type')
            self.recording_audio_type = value
            self.validate_audio_type_option(self.recording_audio_type)    # validate type audio_type_option
        value = find_attr_value_('recording_video_uri', node)
        if value is not None and 'recording_video_uri' not in already_processed:
            already_processed.add('recording_video_uri')
            self.recording_video_uri = value
        value = find_attr_value_('recording_video_type', node)
        if value is not None and 'recording_video_type' not in already_processed:
            already_processed.add('recording_video_type')
            self.recording_video_type = value
            self.validate_recording_video_type_option(self.recording_video_type)    # validate type recording_video_type_option
        value = find_attr_value_('max_silence', node)
        if value is not None and 'max_silence' not in already_processed:
            already_processed.add('max_silence')
            self.max_silence = value
            self.validate_time_value(self.max_silence)    # validate type time_value
        value = find_attr_value_('max_time', node)
        if value is not None and 'max_time' not in already_processed:
            already_processed.add('max_time')
            self.max_time = value
            self.validate_time_value(self.max_time)    # validate type time_value
        value = find_attr_value_('noinput_timeout', node)
        if value is not None and 'noinput_timeout' not in already_processed:
            already_processed.add('noinput_timeout')
            self.noinput_timeout = value
            self.validate_time_value(self.noinput_timeout)    # validate type time_value
        value = find_attr_value_('clamp_dtmf', node)
        if value is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            self.clamp_dtmf = value
            self.validate_boolean_type(self.clamp_dtmf)    # validate type boolean_type
        value = find_attr_value_('append', node)
        if value is not None and 'append' not in already_processed:
            already_processed.add('append')
            self.append = value
            self.validate_boolean_type(self.append)    # validate type boolean_type
        value = find_attr_value_('public_key', node)
        if value is not None and 'public_key' not in already_processed:
            already_processed.add('public_key')
            self.public_key = value
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'recording_audio_mime_params':
            obj_ = recording_audio_mime_params.factory()
            obj_.build(child_)
            self.recording_audio_mime_params = obj_
            obj_.original_tagname_ = 'recording_audio_mime_params'
        elif nodeName_ == 'recording_video_mime_params':
            obj_ = recording_video_mime_params.factory()
            obj_.build(child_)
            self.recording_video_mime_params = obj_
            obj_.original_tagname_ = 'recording_video_mime_params'
# end class record


class playrecord(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, barge='yes', cleardigits='no', offset='0s', repeat='0', delay='1s', recording_uri=None, recording_audio_uri=None, recording_audio_type=None, recording_video_uri=None, recording_video_type='video/x-vid', beep='yes', terminate_digits='#', max_time='infinite', max_silence='infinite', noinput_timeout='infinite', transaction_id=None, no_cache=None, max_age=None, max_stale=None, fetch_timeout='300s', clamp_dtmf=None, public_key=None, play_source=None, recording_audio_mime_params=None, recording_video_mime_params=None):
        self.original_tagname_ = None
        self.barge = _cast(None, barge)
        self.cleardigits = _cast(None, cleardigits)
        self.offset = _cast(None, offset)
        self.repeat = _cast(None, repeat)
        self.delay = _cast(None, delay)
        self.recording_uri = _cast(None, recording_uri)
        self.recording_audio_uri = _cast(None, recording_audio_uri)
        self.recording_audio_type = _cast(None, recording_audio_type)
        self.recording_video_uri = _cast(None, recording_video_uri)
        self.recording_video_type = _cast(None, recording_video_type)
        self.beep = _cast(None, beep)
        self.terminate_digits = _cast(None, terminate_digits)
        self.max_time = _cast(None, max_time)
        self.max_silence = _cast(None, max_silence)
        self.noinput_timeout = _cast(None, noinput_timeout)
        self.transaction_id = _cast(None, transaction_id)
        self.no_cache = _cast(None, no_cache)
        self.max_age = _cast(None, max_age)
        self.max_stale = _cast(None, max_stale)
        self.fetch_timeout = _cast(None, fetch_timeout)
        self.clamp_dtmf = _cast(None, clamp_dtmf)
        self.public_key = _cast(None, public_key)
        self.play_source = play_source
        self.recording_audio_mime_params = recording_audio_mime_params
        self.recording_video_mime_params = recording_video_mime_params
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, playrecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if playrecord.subclass:
            return playrecord.subclass(*args_, **kwargs_)
        else:
            return playrecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_play_source(self): return self.play_source
    def set_play_source(self, play_source): self.play_source = play_source
    def get_recording_audio_mime_params(self): return self.recording_audio_mime_params
    def set_recording_audio_mime_params(self, recording_audio_mime_params): self.recording_audio_mime_params = recording_audio_mime_params
    def get_recording_video_mime_params(self): return self.recording_video_mime_params
    def set_recording_video_mime_params(self, recording_video_mime_params): self.recording_video_mime_params = recording_video_mime_params
    def get_barge(self): return self.barge
    def set_barge(self, barge): self.barge = barge
    def get_cleardigits(self): return self.cleardigits
    def set_cleardigits(self, cleardigits): self.cleardigits = cleardigits
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def get_repeat(self): return self.repeat
    def set_repeat(self, repeat): self.repeat = repeat
    def get_delay(self): return self.delay
    def set_delay(self, delay): self.delay = delay
    def get_recording_uri(self): return self.recording_uri
    def set_recording_uri(self, recording_uri): self.recording_uri = recording_uri
    def get_recording_audio_uri(self): return self.recording_audio_uri
    def set_recording_audio_uri(self, recording_audio_uri): self.recording_audio_uri = recording_audio_uri
    def get_recording_audio_type(self): return self.recording_audio_type
    def set_recording_audio_type(self, recording_audio_type): self.recording_audio_type = recording_audio_type
    def get_recording_video_uri(self): return self.recording_video_uri
    def set_recording_video_uri(self, recording_video_uri): self.recording_video_uri = recording_video_uri
    def get_recording_video_type(self): return self.recording_video_type
    def set_recording_video_type(self, recording_video_type): self.recording_video_type = recording_video_type
    def get_beep(self): return self.beep
    def set_beep(self, beep): self.beep = beep
    def get_terminate_digits(self): return self.terminate_digits
    def set_terminate_digits(self, terminate_digits): self.terminate_digits = terminate_digits
    def get_max_time(self): return self.max_time
    def set_max_time(self, max_time): self.max_time = max_time
    def get_max_silence(self): return self.max_silence
    def set_max_silence(self, max_silence): self.max_silence = max_silence
    def get_noinput_timeout(self): return self.noinput_timeout
    def set_noinput_timeout(self, noinput_timeout): self.noinput_timeout = noinput_timeout
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def get_no_cache(self): return self.no_cache
    def set_no_cache(self, no_cache): self.no_cache = no_cache
    def get_max_age(self): return self.max_age
    def set_max_age(self, max_age): self.max_age = max_age
    def get_max_stale(self): return self.max_stale
    def set_max_stale(self, max_stale): self.max_stale = max_stale
    def get_fetch_timeout(self): return self.fetch_timeout
    def set_fetch_timeout(self, fetch_timeout): self.fetch_timeout = fetch_timeout
    def get_clamp_dtmf(self): return self.clamp_dtmf
    def set_clamp_dtmf(self, clamp_dtmf): self.clamp_dtmf = clamp_dtmf
    def get_public_key(self): return self.public_key
    def set_public_key(self, public_key): self.public_key = public_key
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_integer_value(self, value):
        # Validate type integer_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_integer_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_integer_value_patterns_, ))
    validate_integer_value_patterns_ = [['^[0-9]+$|^infinite$']]
    def validate_audio_type_option(self, value):
        # Validate type audio_type_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio/x-wav', 'audio/basic', 'audio/x-alaw-basic', 'audio/L8', 'audio/L16', 'audio/x-aud', 'audio/AMR', 'audio/AMR-WB', 'audio/3gpp', 'audio/mp4', 'audio/mkv', 'audio/webm', 'audio/evs', 'text/uri-list']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on audio_type_option' % {"value" : value.encode("utf-8")} )
    def validate_recording_video_type_option(self, value):
        # Validate type recording_video_type_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['video/x-vid', 'video/3gpp', 'image/jpeg', 'video/mp4', 'video/mkv', 'video/webm']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on recording_video_type_option' % {"value" : value.encode("utf-8")} )
    def validate_digit_value(self, value):
        # Validate type digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_digit_value_patterns_, ))
    validate_digit_value_patterns_ = [['^[0-9#*]+$|^$']]
    def hasContent_(self):
        if (
            self.play_source is not None or
            self.recording_audio_mime_params is not None or
            self.recording_video_mime_params is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='playrecord', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('playrecord')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='playrecord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='playrecord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='playrecord'):
        if self.barge != "yes" and 'barge' not in already_processed:
            already_processed.add('barge')
            outfile.write(' barge=%s' % (quote_attrib(self.barge), ))
        if self.cleardigits != "no" and 'cleardigits' not in already_processed:
            already_processed.add('cleardigits')
            outfile.write(' cleardigits=%s' % (quote_attrib(self.cleardigits), ))
        if self.offset != "0s" and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset=%s' % (quote_attrib(self.offset), ))
        if self.repeat != "0" and 'repeat' not in already_processed:
            already_processed.add('repeat')
            outfile.write(' repeat=%s' % (quote_attrib(self.repeat), ))
        if self.delay != "1s" and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (quote_attrib(self.delay), ))
        if self.recording_uri is not None and 'recording_uri' not in already_processed:
            already_processed.add('recording_uri')
            outfile.write(' recording_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.recording_uri), input_name='recording_uri')), ))
        if self.recording_audio_uri is not None and 'recording_audio_uri' not in already_processed:
            already_processed.add('recording_audio_uri')
            outfile.write(' recording_audio_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.recording_audio_uri), input_name='recording_audio_uri')), ))
        if self.recording_audio_type is not None and 'recording_audio_type' not in already_processed:
            already_processed.add('recording_audio_type')
            outfile.write(' recording_audio_type=%s' % (quote_attrib(self.recording_audio_type), ))
        if self.recording_video_uri is not None and 'recording_video_uri' not in already_processed:
            already_processed.add('recording_video_uri')
            outfile.write(' recording_video_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.recording_video_uri), input_name='recording_video_uri')), ))
        if self.recording_video_type != "video/x-vid" and 'recording_video_type' not in already_processed:
            already_processed.add('recording_video_type')
            outfile.write(' recording_video_type=%s' % (quote_attrib(self.recording_video_type), ))
        if self.beep != "yes" and 'beep' not in already_processed:
            already_processed.add('beep')
            outfile.write(' beep=%s' % (quote_attrib(self.beep), ))
        if self.terminate_digits != "#" and 'terminate_digits' not in already_processed:
            already_processed.add('terminate_digits')
            outfile.write(' terminate_digits=%s' % (quote_attrib(self.terminate_digits), ))
        if self.max_time != "infinite" and 'max_time' not in already_processed:
            already_processed.add('max_time')
            outfile.write(' max_time=%s' % (quote_attrib(self.max_time), ))
        if self.max_silence != "infinite" and 'max_silence' not in already_processed:
            already_processed.add('max_silence')
            outfile.write(' max_silence=%s' % (quote_attrib(self.max_silence), ))
        if self.noinput_timeout != "infinite" and 'noinput_timeout' not in already_processed:
            already_processed.add('noinput_timeout')
            outfile.write(' noinput_timeout=%s' % (quote_attrib(self.noinput_timeout), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
        if self.no_cache is not None and 'no_cache' not in already_processed:
            already_processed.add('no_cache')
            outfile.write(' no_cache=%s' % (quote_attrib(self.no_cache), ))
        if self.max_age is not None and 'max_age' not in already_processed:
            already_processed.add('max_age')
            outfile.write(' max_age=%s' % (quote_attrib(self.max_age), ))
        if self.max_stale is not None and 'max_stale' not in already_processed:
            already_processed.add('max_stale')
            outfile.write(' max_stale=%s' % (quote_attrib(self.max_stale), ))
        if self.fetch_timeout != "300s" and 'fetch_timeout' not in already_processed:
            already_processed.add('fetch_timeout')
            outfile.write(' fetch_timeout=%s' % (quote_attrib(self.fetch_timeout), ))
        if self.clamp_dtmf is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            outfile.write(' clamp_dtmf=%s' % (quote_attrib(self.clamp_dtmf), ))
        if self.public_key is not None and 'public_key' not in already_processed:
            already_processed.add('public_key')
            outfile.write(' public_key=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.public_key), input_name='public_key')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='playrecord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.play_source is not None:
            self.play_source.export(outfile, level, namespace_, name_='play_source', pretty_print=pretty_print)
        if self.recording_audio_mime_params is not None:
            self.recording_audio_mime_params.export(outfile, level, namespace_, name_='recording_audio_mime_params', pretty_print=pretty_print)
        if self.recording_video_mime_params is not None:
            self.recording_video_mime_params.export(outfile, level, namespace_, name_='recording_video_mime_params', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('barge', node)
        if value is not None and 'barge' not in already_processed:
            already_processed.add('barge')
            self.barge = value
            self.validate_boolean_type(self.barge)    # validate type boolean_type
        value = find_attr_value_('cleardigits', node)
        if value is not None and 'cleardigits' not in already_processed:
            already_processed.add('cleardigits')
            self.cleardigits = value
            self.validate_boolean_type(self.cleardigits)    # validate type boolean_type
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = value
            self.validate_time_value(self.offset)    # validate type time_value
        value = find_attr_value_('repeat', node)
        if value is not None and 'repeat' not in already_processed:
            already_processed.add('repeat')
            self.repeat = value
            self.validate_integer_value(self.repeat)    # validate type integer_value
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_time_value(self.delay)    # validate type time_value
        value = find_attr_value_('recording_uri', node)
        if value is not None and 'recording_uri' not in already_processed:
            already_processed.add('recording_uri')
            self.recording_uri = value
        value = find_attr_value_('recording_audio_uri', node)
        if value is not None and 'recording_audio_uri' not in already_processed:
            already_processed.add('recording_audio_uri')
            self.recording_audio_uri = value
        value = find_attr_value_('recording_audio_type', node)
        if value is not None and 'recording_audio_type' not in already_processed:
            already_processed.add('recording_audio_type')
            self.recording_audio_type = value
            self.validate_audio_type_option(self.recording_audio_type)    # validate type audio_type_option
        value = find_attr_value_('recording_video_uri', node)
        if value is not None and 'recording_video_uri' not in already_processed:
            already_processed.add('recording_video_uri')
            self.recording_video_uri = value
        value = find_attr_value_('recording_video_type', node)
        if value is not None and 'recording_video_type' not in already_processed:
            already_processed.add('recording_video_type')
            self.recording_video_type = value
            self.validate_recording_video_type_option(self.recording_video_type)    # validate type recording_video_type_option
        value = find_attr_value_('beep', node)
        if value is not None and 'beep' not in already_processed:
            already_processed.add('beep')
            self.beep = value
            self.validate_boolean_type(self.beep)    # validate type boolean_type
        value = find_attr_value_('terminate_digits', node)
        if value is not None and 'terminate_digits' not in already_processed:
            already_processed.add('terminate_digits')
            self.terminate_digits = value
            self.validate_digit_value(self.terminate_digits)    # validate type digit_value
        value = find_attr_value_('max_time', node)
        if value is not None and 'max_time' not in already_processed:
            already_processed.add('max_time')
            self.max_time = value
            self.validate_time_value(self.max_time)    # validate type time_value
        value = find_attr_value_('max_silence', node)
        if value is not None and 'max_silence' not in already_processed:
            already_processed.add('max_silence')
            self.max_silence = value
            self.validate_time_value(self.max_silence)    # validate type time_value
        value = find_attr_value_('noinput_timeout', node)
        if value is not None and 'noinput_timeout' not in already_processed:
            already_processed.add('noinput_timeout')
            self.noinput_timeout = value
            self.validate_time_value(self.noinput_timeout)    # validate type time_value
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
        value = find_attr_value_('no_cache', node)
        if value is not None and 'no_cache' not in already_processed:
            already_processed.add('no_cache')
            self.no_cache = value
            self.validate_boolean_type(self.no_cache)    # validate type boolean_type
        value = find_attr_value_('max_age', node)
        if value is not None and 'max_age' not in already_processed:
            already_processed.add('max_age')
            self.max_age = value
            self.validate_time_value(self.max_age)    # validate type time_value
        value = find_attr_value_('max_stale', node)
        if value is not None and 'max_stale' not in already_processed:
            already_processed.add('max_stale')
            self.max_stale = value
            self.validate_time_value(self.max_stale)    # validate type time_value
        value = find_attr_value_('fetch_timeout', node)
        if value is not None and 'fetch_timeout' not in already_processed:
            already_processed.add('fetch_timeout')
            self.fetch_timeout = value
            self.validate_time_value(self.fetch_timeout)    # validate type time_value
        value = find_attr_value_('clamp_dtmf', node)
        if value is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            self.clamp_dtmf = value
            self.validate_boolean_type(self.clamp_dtmf)    # validate type boolean_type
        value = find_attr_value_('public_key', node)
        if value is not None and 'public_key' not in already_processed:
            already_processed.add('public_key')
            self.public_key = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'play_source':
            obj_ = play_source.factory()
            obj_.build(child_)
            self.play_source = obj_
            obj_.original_tagname_ = 'play_source'
        elif nodeName_ == 'recording_audio_mime_params':
            obj_ = recording_audio_mime_params.factory()
            obj_.build(child_)
            self.recording_audio_mime_params = obj_
            obj_.original_tagname_ = 'recording_audio_mime_params'
        elif nodeName_ == 'recording_video_mime_params':
            obj_ = recording_video_mime_params.factory()
            obj_.build(child_)
            self.recording_video_mime_params = obj_
            obj_.original_tagname_ = 'recording_video_mime_params'
# end class playrecord


class playcollect(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, barge='yes', cleardigits='no', offset='0s', repeat='0', delay='1s', max_digits=None, timeout=None, interdigit_timeout=None, terminate_digits='#', tone_detection='no', transaction_id=None, no_cache=None, max_age=None, max_stale=None, fetch_timeout='300s', play_source=None):
        self.original_tagname_ = None
        self.barge = _cast(None, barge)
        self.cleardigits = _cast(None, cleardigits)
        self.offset = _cast(None, offset)
        self.repeat = _cast(None, repeat)
        self.delay = _cast(None, delay)
        self.max_digits = _cast(None, max_digits)
        self.timeout = _cast(None, timeout)
        self.interdigit_timeout = _cast(None, interdigit_timeout)
        self.terminate_digits = _cast(None, terminate_digits)
        self.tone_detection = _cast(None, tone_detection)
        self.transaction_id = _cast(None, transaction_id)
        self.no_cache = _cast(None, no_cache)
        self.max_age = _cast(None, max_age)
        self.max_stale = _cast(None, max_stale)
        self.fetch_timeout = _cast(None, fetch_timeout)
        self.play_source = play_source
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, playcollect)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if playcollect.subclass:
            return playcollect.subclass(*args_, **kwargs_)
        else:
            return playcollect(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_play_source(self): return self.play_source
    def set_play_source(self, play_source): self.play_source = play_source
    def get_barge(self): return self.barge
    def set_barge(self, barge): self.barge = barge
    def get_cleardigits(self): return self.cleardigits
    def set_cleardigits(self, cleardigits): self.cleardigits = cleardigits
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def get_repeat(self): return self.repeat
    def set_repeat(self, repeat): self.repeat = repeat
    def get_delay(self): return self.delay
    def set_delay(self, delay): self.delay = delay
    def get_max_digits(self): return self.max_digits
    def set_max_digits(self, max_digits): self.max_digits = max_digits
    def get_timeout(self): return self.timeout
    def set_timeout(self, timeout): self.timeout = timeout
    def get_interdigit_timeout(self): return self.interdigit_timeout
    def set_interdigit_timeout(self, interdigit_timeout): self.interdigit_timeout = interdigit_timeout
    def get_terminate_digits(self): return self.terminate_digits
    def set_terminate_digits(self, terminate_digits): self.terminate_digits = terminate_digits
    def get_tone_detection(self): return self.tone_detection
    def set_tone_detection(self, tone_detection): self.tone_detection = tone_detection
    def get_transaction_id(self): return self.transaction_id
    def set_transaction_id(self, transaction_id): self.transaction_id = transaction_id
    def get_no_cache(self): return self.no_cache
    def set_no_cache(self, no_cache): self.no_cache = no_cache
    def get_max_age(self): return self.max_age
    def set_max_age(self, max_age): self.max_age = max_age
    def get_max_stale(self): return self.max_stale
    def set_max_stale(self, max_stale): self.max_stale = max_stale
    def get_fetch_timeout(self): return self.fetch_timeout
    def set_fetch_timeout(self, fetch_timeout): self.fetch_timeout = fetch_timeout
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_integer_value(self, value):
        # Validate type integer_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_integer_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_integer_value_patterns_, ))
    validate_integer_value_patterns_ = [['^[0-9]+$|^infinite$']]
    def validate_digit_value(self, value):
        # Validate type digit_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_digit_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_digit_value_patterns_, ))
    validate_digit_value_patterns_ = [['^[0-9#*]+$|^$']]
    def hasContent_(self):
        if (
            self.play_source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='playcollect', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('playcollect')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='playcollect')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='playcollect', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='playcollect'):
        if self.barge != "yes" and 'barge' not in already_processed:
            already_processed.add('barge')
            outfile.write(' barge=%s' % (quote_attrib(self.barge), ))
        if self.cleardigits != "no" and 'cleardigits' not in already_processed:
            already_processed.add('cleardigits')
            outfile.write(' cleardigits=%s' % (quote_attrib(self.cleardigits), ))
        if self.offset != "0s" and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset=%s' % (quote_attrib(self.offset), ))
        if self.repeat != "0" and 'repeat' not in already_processed:
            already_processed.add('repeat')
            outfile.write(' repeat=%s' % (quote_attrib(self.repeat), ))
        if self.delay != "1s" and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (quote_attrib(self.delay), ))
        if self.max_digits is not None and 'max_digits' not in already_processed:
            already_processed.add('max_digits')
            outfile.write(' max_digits=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.max_digits), input_name='max_digits')), ))
        if self.timeout is not None and 'timeout' not in already_processed:
            already_processed.add('timeout')
            outfile.write(' timeout=%s' % (quote_attrib(self.timeout), ))
        if self.interdigit_timeout is not None and 'interdigit_timeout' not in already_processed:
            already_processed.add('interdigit_timeout')
            outfile.write(' interdigit_timeout=%s' % (quote_attrib(self.interdigit_timeout), ))
        if self.terminate_digits != "#" and 'terminate_digits' not in already_processed:
            already_processed.add('terminate_digits')
            outfile.write(' terminate_digits=%s' % (quote_attrib(self.terminate_digits), ))
        if self.tone_detection != "no" and 'tone_detection' not in already_processed:
            already_processed.add('tone_detection')
            outfile.write(' tone_detection=%s' % (quote_attrib(self.tone_detection), ))
        if self.transaction_id is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            outfile.write(' transaction_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transaction_id), input_name='transaction_id')), ))
        if self.no_cache is not None and 'no_cache' not in already_processed:
            already_processed.add('no_cache')
            outfile.write(' no_cache=%s' % (quote_attrib(self.no_cache), ))
        if self.max_age is not None and 'max_age' not in already_processed:
            already_processed.add('max_age')
            outfile.write(' max_age=%s' % (quote_attrib(self.max_age), ))
        if self.max_stale is not None and 'max_stale' not in already_processed:
            already_processed.add('max_stale')
            outfile.write(' max_stale=%s' % (quote_attrib(self.max_stale), ))
        if self.fetch_timeout != "300s" and 'fetch_timeout' not in already_processed:
            already_processed.add('fetch_timeout')
            outfile.write(' fetch_timeout=%s' % (quote_attrib(self.fetch_timeout), ))
    def exportChildren(self, outfile, level, namespace_='', name_='playcollect', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.play_source is not None:
            self.play_source.export(outfile, level, namespace_, name_='play_source', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('barge', node)
        if value is not None and 'barge' not in already_processed:
            already_processed.add('barge')
            self.barge = value
            self.validate_boolean_type(self.barge)    # validate type boolean_type
        value = find_attr_value_('cleardigits', node)
        if value is not None and 'cleardigits' not in already_processed:
            already_processed.add('cleardigits')
            self.cleardigits = value
            self.validate_boolean_type(self.cleardigits)    # validate type boolean_type
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = value
            self.validate_time_value(self.offset)    # validate type time_value
        value = find_attr_value_('repeat', node)
        if value is not None and 'repeat' not in already_processed:
            already_processed.add('repeat')
            self.repeat = value
            self.validate_integer_value(self.repeat)    # validate type integer_value
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_time_value(self.delay)    # validate type time_value
        value = find_attr_value_('max_digits', node)
        if value is not None and 'max_digits' not in already_processed:
            already_processed.add('max_digits')
            self.max_digits = value
        value = find_attr_value_('timeout', node)
        if value is not None and 'timeout' not in already_processed:
            already_processed.add('timeout')
            self.timeout = value
            self.validate_time_value(self.timeout)    # validate type time_value
        value = find_attr_value_('interdigit_timeout', node)
        if value is not None and 'interdigit_timeout' not in already_processed:
            already_processed.add('interdigit_timeout')
            self.interdigit_timeout = value
            self.validate_time_value(self.interdigit_timeout)    # validate type time_value
        value = find_attr_value_('terminate_digits', node)
        if value is not None and 'terminate_digits' not in already_processed:
            already_processed.add('terminate_digits')
            self.terminate_digits = value
            self.validate_digit_value(self.terminate_digits)    # validate type digit_value
        value = find_attr_value_('tone_detection', node)
        if value is not None and 'tone_detection' not in already_processed:
            already_processed.add('tone_detection')
            self.tone_detection = value
            self.validate_boolean_type(self.tone_detection)    # validate type boolean_type
        value = find_attr_value_('transaction_id', node)
        if value is not None and 'transaction_id' not in already_processed:
            already_processed.add('transaction_id')
            self.transaction_id = value
        value = find_attr_value_('no_cache', node)
        if value is not None and 'no_cache' not in already_processed:
            already_processed.add('no_cache')
            self.no_cache = value
            self.validate_boolean_type(self.no_cache)    # validate type boolean_type
        value = find_attr_value_('max_age', node)
        if value is not None and 'max_age' not in already_processed:
            already_processed.add('max_age')
            self.max_age = value
            self.validate_time_value(self.max_age)    # validate type time_value
        value = find_attr_value_('max_stale', node)
        if value is not None and 'max_stale' not in already_processed:
            already_processed.add('max_stale')
            self.max_stale = value
            self.validate_time_value(self.max_stale)    # validate type time_value
        value = find_attr_value_('fetch_timeout', node)
        if value is not None and 'fetch_timeout' not in already_processed:
            already_processed.add('fetch_timeout')
            self.fetch_timeout = value
            self.validate_time_value(self.fetch_timeout)    # validate type time_value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'play_source':
            obj_ = play_source.factory()
            obj_.build(child_)
            self.play_source = obj_
            obj_.original_tagname_ = 'play_source'
# end class playcollect


class error(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, code=None, description=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        self.description = _cast(None, description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, error)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if error.subclass:
            return error.subclass(*args_, **kwargs_)
        else:
            return error(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='error', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('error')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='error')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='error', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='error'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='error', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class error


class call(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, answer=None, signaling='yes', media=None, source_uri=None, destination_uri=None, called_uri=None, display_name=None, sdp=None, cpa=None, dtmf_mode=None, async_dtmf=None, async_tone=None, rx_delta=None, tx_delta=None, cleardigits=None, info_ack_mode=None, hangup_ack_mode=None, early_media=None, audio=None, video=None, message=None, image=None, accept=None, async_completion=None, dial_timeout=None, encryption=None, ice=None, setup=None, content=None, content_type=None, local_rtp_address=None, answer_ack_mode=None, prack_mode=None, prack_ack_mode=None, prack_level=None, rtcp_feedback=None, local_events=None, gusid=None, cpa_profile=None, codec_profile=None, call_action=None, sip_headers=None):
        self.original_tagname_ = None
        self.answer = _cast(None, answer)
        self.signaling = _cast(None, signaling)
        self.media = _cast(None, media)
        self.source_uri = _cast(None, source_uri)
        self.destination_uri = _cast(None, destination_uri)
        self.called_uri = _cast(None, called_uri)
        self.display_name = _cast(None, display_name)
        self.sdp = _cast(None, sdp)
        self.cpa = _cast(None, cpa)
        self.dtmf_mode = _cast(None, dtmf_mode)
        self.async_dtmf = _cast(None, async_dtmf)
        self.async_tone = _cast(None, async_tone)
        self.rx_delta = _cast(None, rx_delta)
        self.tx_delta = _cast(None, tx_delta)
        self.cleardigits = _cast(None, cleardigits)
        self.info_ack_mode = _cast(None, info_ack_mode)
        self.hangup_ack_mode = _cast(None, hangup_ack_mode)
        self.early_media = _cast(None, early_media)
        self.audio = _cast(None, audio)
        self.video = _cast(None, video)
        self.message = _cast(None, message)
        self.image = _cast(None, image)
        self.accept = _cast(None, accept)
        self.async_completion = _cast(None, async_completion)
        self.dial_timeout = _cast(None, dial_timeout)
        self.encryption = _cast(None, encryption)
        self.ice = _cast(None, ice)
        self.setup = _cast(None, setup)
        self.content = _cast(None, content)
        self.content_type = _cast(None, content_type)
        self.local_rtp_address = _cast(None, local_rtp_address)
        self.answer_ack_mode = _cast(None, answer_ack_mode)
        self.prack_mode = _cast(None, prack_mode)
        self.prack_ack_mode = _cast(None, prack_ack_mode)
        self.prack_level = _cast(None, prack_level)
        self.rtcp_feedback = _cast(None, rtcp_feedback)
        self.local_events = _cast(None, local_events)
        self.gusid = _cast(None, gusid)
        self.cpa_profile = _cast(None, cpa_profile)
        self.codec_profile = _cast(None, codec_profile)
        self.call_action = call_action
        self.sip_headers = sip_headers
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, call)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if call.subclass:
            return call.subclass(*args_, **kwargs_)
        else:
            return call(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_call_action(self): return self.call_action
    def set_call_action(self, call_action): self.call_action = call_action
    def get_sip_headers(self): return self.sip_headers
    def set_sip_headers(self, sip_headers): self.sip_headers = sip_headers
    def get_answer(self): return self.answer
    def set_answer(self, answer): self.answer = answer
    def get_signaling(self): return self.signaling
    def set_signaling(self, signaling): self.signaling = signaling
    def get_media(self): return self.media
    def set_media(self, media): self.media = media
    def get_source_uri(self): return self.source_uri
    def set_source_uri(self, source_uri): self.source_uri = source_uri
    def get_destination_uri(self): return self.destination_uri
    def set_destination_uri(self, destination_uri): self.destination_uri = destination_uri
    def get_called_uri(self): return self.called_uri
    def set_called_uri(self, called_uri): self.called_uri = called_uri
    def get_display_name(self): return self.display_name
    def set_display_name(self, display_name): self.display_name = display_name
    def get_sdp(self): return self.sdp
    def set_sdp(self, sdp): self.sdp = sdp
    def get_cpa(self): return self.cpa
    def set_cpa(self, cpa): self.cpa = cpa
    def get_dtmf_mode(self): return self.dtmf_mode
    def set_dtmf_mode(self, dtmf_mode): self.dtmf_mode = dtmf_mode
    def get_async_dtmf(self): return self.async_dtmf
    def set_async_dtmf(self, async_dtmf): self.async_dtmf = async_dtmf
    def get_async_tone(self): return self.async_tone
    def set_async_tone(self, async_tone): self.async_tone = async_tone
    def get_rx_delta(self): return self.rx_delta
    def set_rx_delta(self, rx_delta): self.rx_delta = rx_delta
    def get_tx_delta(self): return self.tx_delta
    def set_tx_delta(self, tx_delta): self.tx_delta = tx_delta
    def get_cleardigits(self): return self.cleardigits
    def set_cleardigits(self, cleardigits): self.cleardigits = cleardigits
    def get_info_ack_mode(self): return self.info_ack_mode
    def set_info_ack_mode(self, info_ack_mode): self.info_ack_mode = info_ack_mode
    def get_hangup_ack_mode(self): return self.hangup_ack_mode
    def set_hangup_ack_mode(self, hangup_ack_mode): self.hangup_ack_mode = hangup_ack_mode
    def get_early_media(self): return self.early_media
    def set_early_media(self, early_media): self.early_media = early_media
    def get_audio(self): return self.audio
    def set_audio(self, audio): self.audio = audio
    def get_video(self): return self.video
    def set_video(self, video): self.video = video
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_image(self): return self.image
    def set_image(self, image): self.image = image
    def get_accept(self): return self.accept
    def set_accept(self, accept): self.accept = accept
    def get_async_completion(self): return self.async_completion
    def set_async_completion(self, async_completion): self.async_completion = async_completion
    def get_dial_timeout(self): return self.dial_timeout
    def set_dial_timeout(self, dial_timeout): self.dial_timeout = dial_timeout
    def get_encryption(self): return self.encryption
    def set_encryption(self, encryption): self.encryption = encryption
    def get_ice(self): return self.ice
    def set_ice(self, ice): self.ice = ice
    def get_setup(self): return self.setup
    def set_setup(self, setup): self.setup = setup
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_local_rtp_address(self): return self.local_rtp_address
    def set_local_rtp_address(self, local_rtp_address): self.local_rtp_address = local_rtp_address
    def get_answer_ack_mode(self): return self.answer_ack_mode
    def set_answer_ack_mode(self, answer_ack_mode): self.answer_ack_mode = answer_ack_mode
    def get_prack_mode(self): return self.prack_mode
    def set_prack_mode(self, prack_mode): self.prack_mode = prack_mode
    def get_prack_ack_mode(self): return self.prack_ack_mode
    def set_prack_ack_mode(self, prack_ack_mode): self.prack_ack_mode = prack_ack_mode
    def get_prack_level(self): return self.prack_level
    def set_prack_level(self, prack_level): self.prack_level = prack_level
    def get_rtcp_feedback(self): return self.rtcp_feedback
    def set_rtcp_feedback(self, rtcp_feedback): self.rtcp_feedback = rtcp_feedback
    def get_local_events(self): return self.local_events
    def set_local_events(self, local_events): self.local_events = local_events
    def get_gusid(self): return self.gusid
    def set_gusid(self, gusid): self.gusid = gusid
    def get_cpa_profile(self): return self.cpa_profile
    def set_cpa_profile(self, cpa_profile): self.cpa_profile = cpa_profile
    def get_codec_profile(self): return self.codec_profile
    def set_codec_profile(self, codec_profile): self.codec_profile = codec_profile
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def validate_media_type(self, value):
        # Validate type media_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio', 'video', 'audiovideo', 'message', 'image', 'unknown', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_type' % {"value" : value.encode("utf-8")} )
    def validate_dtmf_mode_option(self, value):
        # Validate type dtmf_mode_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inband', 'outofband', 'rfc2833']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on dtmf_mode_option' % {"value" : value.encode("utf-8")} )
    def validate_volume_range(self, value):
        # Validate type volume_range, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_volume_range_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_volume_range_patterns_, ))
    validate_volume_range_patterns_ = [['^((\\+$|^)([0-9]$|^1[0-9]$|^2[0-9]$|^3[0-1])$|^(\\-)([0-9]$|^1[0-9]$|^2[0-9]$|^3[0-2]))((dB$|^db$|^DB$|^Db)$|^(dB$|^db$|^DB$|^Db)(;)(relative$|^absolute))$']]
    def validate_ack_mode_option(self, value):
        # Validate type ack_mode_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['automatic', 'manual']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ack_mode_option' % {"value" : value.encode("utf-8")} )
    def validate_media_direction(self, value):
        # Validate type media_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inactive', 'sendonly', 'recvonly', 'sendrecv']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_direction' % {"value" : value.encode("utf-8")} )
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def validate_rtp_encryption_option(self, value):
        # Validate type rtp_encryption_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'dtls', 'srtp']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on rtp_encryption_option' % {"value" : value.encode("utf-8")} )
    def validate_rtcp_feedback_mode_option(self, value):
        # Validate type rtcp_feedback_mode_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio', 'video', 'audiovideo', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on rtcp_feedback_mode_option' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.call_action is not None or
            self.sip_headers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='call', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('call')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='call')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='call', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='call'):
        if self.answer is not None and 'answer' not in already_processed:
            already_processed.add('answer')
            outfile.write(' answer=%s' % (quote_attrib(self.answer), ))
        if self.signaling != "yes" and 'signaling' not in already_processed:
            already_processed.add('signaling')
            outfile.write(' signaling=%s' % (quote_attrib(self.signaling), ))
        if self.media is not None and 'media' not in already_processed:
            already_processed.add('media')
            outfile.write(' media=%s' % (quote_attrib(self.media), ))
        if self.source_uri is not None and 'source_uri' not in already_processed:
            already_processed.add('source_uri')
            outfile.write(' source_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source_uri), input_name='source_uri')), ))
        if self.destination_uri is not None and 'destination_uri' not in already_processed:
            already_processed.add('destination_uri')
            outfile.write(' destination_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.destination_uri), input_name='destination_uri')), ))
        if self.called_uri is not None and 'called_uri' not in already_processed:
            already_processed.add('called_uri')
            outfile.write(' called_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.called_uri), input_name='called_uri')), ))
        if self.display_name is not None and 'display_name' not in already_processed:
            already_processed.add('display_name')
            outfile.write(' display_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.display_name), input_name='display_name')), ))
        if self.sdp is not None and 'sdp' not in already_processed:
            already_processed.add('sdp')
            outfile.write(' sdp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sdp), input_name='sdp')), ))
        if self.cpa is not None and 'cpa' not in already_processed:
            already_processed.add('cpa')
            outfile.write(' cpa=%s' % (quote_attrib(self.cpa), ))
        if self.dtmf_mode is not None and 'dtmf_mode' not in already_processed:
            already_processed.add('dtmf_mode')
            outfile.write(' dtmf_mode=%s' % (quote_attrib(self.dtmf_mode), ))
        if self.async_dtmf is not None and 'async_dtmf' not in already_processed:
            already_processed.add('async_dtmf')
            outfile.write(' async_dtmf=%s' % (quote_attrib(self.async_dtmf), ))
        if self.async_tone is not None and 'async_tone' not in already_processed:
            already_processed.add('async_tone')
            outfile.write(' async_tone=%s' % (quote_attrib(self.async_tone), ))
        if self.rx_delta is not None and 'rx_delta' not in already_processed:
            already_processed.add('rx_delta')
            outfile.write(' rx_delta=%s' % (quote_attrib(self.rx_delta), ))
        if self.tx_delta is not None and 'tx_delta' not in already_processed:
            already_processed.add('tx_delta')
            outfile.write(' tx_delta=%s' % (quote_attrib(self.tx_delta), ))
        if self.cleardigits is not None and 'cleardigits' not in already_processed:
            already_processed.add('cleardigits')
            outfile.write(' cleardigits=%s' % (quote_attrib(self.cleardigits), ))
        if self.info_ack_mode is not None and 'info_ack_mode' not in already_processed:
            already_processed.add('info_ack_mode')
            outfile.write(' info_ack_mode=%s' % (quote_attrib(self.info_ack_mode), ))
        if self.hangup_ack_mode is not None and 'hangup_ack_mode' not in already_processed:
            already_processed.add('hangup_ack_mode')
            outfile.write(' hangup_ack_mode=%s' % (quote_attrib(self.hangup_ack_mode), ))
        if self.early_media is not None and 'early_media' not in already_processed:
            already_processed.add('early_media')
            outfile.write(' early_media=%s' % (quote_attrib(self.early_media), ))
        if self.audio is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            outfile.write(' audio=%s' % (quote_attrib(self.audio), ))
        if self.video is not None and 'video' not in already_processed:
            already_processed.add('video')
            outfile.write(' video=%s' % (quote_attrib(self.video), ))
        if self.message is not None and 'message' not in already_processed:
            already_processed.add('message')
            outfile.write(' message=%s' % (quote_attrib(self.message), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (quote_attrib(self.image), ))
        if self.accept is not None and 'accept' not in already_processed:
            already_processed.add('accept')
            outfile.write(' accept=%s' % (quote_attrib(self.accept), ))
        if self.async_completion is not None and 'async_completion' not in already_processed:
            already_processed.add('async_completion')
            outfile.write(' async_completion=%s' % (quote_attrib(self.async_completion), ))
        if self.dial_timeout is not None and 'dial_timeout' not in already_processed:
            already_processed.add('dial_timeout')
            outfile.write(' dial_timeout=%s' % (quote_attrib(self.dial_timeout), ))
        if self.encryption is not None and 'encryption' not in already_processed:
            already_processed.add('encryption')
            outfile.write(' encryption=%s' % (quote_attrib(self.encryption), ))
        if self.ice is not None and 'ice' not in already_processed:
            already_processed.add('ice')
            outfile.write(' ice=%s' % (quote_attrib(self.ice), ))
        if self.setup is not None and 'setup' not in already_processed:
            already_processed.add('setup')
            outfile.write(' setup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.setup), input_name='setup')), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_type), input_name='content_type')), ))
        if self.local_rtp_address is not None and 'local_rtp_address' not in already_processed:
            already_processed.add('local_rtp_address')
            outfile.write(' local_rtp_address=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.local_rtp_address), input_name='local_rtp_address')), ))
        if self.answer_ack_mode is not None and 'answer_ack_mode' not in already_processed:
            already_processed.add('answer_ack_mode')
            outfile.write(' answer_ack_mode=%s' % (quote_attrib(self.answer_ack_mode), ))
        if self.prack_mode is not None and 'prack_mode' not in already_processed:
            already_processed.add('prack_mode')
            outfile.write(' prack_mode=%s' % (quote_attrib(self.prack_mode), ))
        if self.prack_ack_mode is not None and 'prack_ack_mode' not in already_processed:
            already_processed.add('prack_ack_mode')
            outfile.write(' prack_ack_mode=%s' % (quote_attrib(self.prack_ack_mode), ))
        if self.prack_level is not None and 'prack_level' not in already_processed:
            already_processed.add('prack_level')
            outfile.write(' prack_level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prack_level), input_name='prack_level')), ))
        if self.rtcp_feedback is not None and 'rtcp_feedback' not in already_processed:
            already_processed.add('rtcp_feedback')
            outfile.write(' rtcp_feedback=%s' % (quote_attrib(self.rtcp_feedback), ))
        if self.local_events is not None and 'local_events' not in already_processed:
            already_processed.add('local_events')
            outfile.write(' local_events=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.local_events), input_name='local_events')), ))
        if self.gusid is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            outfile.write(' gusid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gusid), input_name='gusid')), ))
        if self.cpa_profile is not None and 'cpa_profile' not in already_processed:
            already_processed.add('cpa_profile')
            outfile.write(' cpa_profile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cpa_profile), input_name='cpa_profile')), ))
        if self.codec_profile is not None and 'codec_profile' not in already_processed:
            already_processed.add('codec_profile')
            outfile.write(' codec_profile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codec_profile), input_name='codec_profile')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='call', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.call_action is not None:
            self.call_action.export(outfile, level, namespace_, name_='call_action', pretty_print=pretty_print)
        if self.sip_headers is not None:
            self.sip_headers.export(outfile, level, namespace_, name_='sip_headers', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('answer', node)
        if value is not None and 'answer' not in already_processed:
            already_processed.add('answer')
            self.answer = value
            self.validate_boolean_type(self.answer)    # validate type boolean_type
        value = find_attr_value_('signaling', node)
        if value is not None and 'signaling' not in already_processed:
            already_processed.add('signaling')
            self.signaling = value
            self.validate_boolean_type(self.signaling)    # validate type boolean_type
        value = find_attr_value_('media', node)
        if value is not None and 'media' not in already_processed:
            already_processed.add('media')
            self.media = value
            self.validate_media_type(self.media)    # validate type media_type
        value = find_attr_value_('source_uri', node)
        if value is not None and 'source_uri' not in already_processed:
            already_processed.add('source_uri')
            self.source_uri = value
        value = find_attr_value_('destination_uri', node)
        if value is not None and 'destination_uri' not in already_processed:
            already_processed.add('destination_uri')
            self.destination_uri = value
        value = find_attr_value_('called_uri', node)
        if value is not None and 'called_uri' not in already_processed:
            already_processed.add('called_uri')
            self.called_uri = value
        value = find_attr_value_('display_name', node)
        if value is not None and 'display_name' not in already_processed:
            already_processed.add('display_name')
            self.display_name = value
        value = find_attr_value_('sdp', node)
        if value is not None and 'sdp' not in already_processed:
            already_processed.add('sdp')
            self.sdp = value
        value = find_attr_value_('cpa', node)
        if value is not None and 'cpa' not in already_processed:
            already_processed.add('cpa')
            self.cpa = value
            self.validate_boolean_type(self.cpa)    # validate type boolean_type
        value = find_attr_value_('dtmf_mode', node)
        if value is not None and 'dtmf_mode' not in already_processed:
            already_processed.add('dtmf_mode')
            self.dtmf_mode = value
            self.validate_dtmf_mode_option(self.dtmf_mode)    # validate type dtmf_mode_option
        value = find_attr_value_('async_dtmf', node)
        if value is not None and 'async_dtmf' not in already_processed:
            already_processed.add('async_dtmf')
            self.async_dtmf = value
            self.validate_boolean_type(self.async_dtmf)    # validate type boolean_type
        value = find_attr_value_('async_tone', node)
        if value is not None and 'async_tone' not in already_processed:
            already_processed.add('async_tone')
            self.async_tone = value
            self.validate_boolean_type(self.async_tone)    # validate type boolean_type
        value = find_attr_value_('rx_delta', node)
        if value is not None and 'rx_delta' not in already_processed:
            already_processed.add('rx_delta')
            self.rx_delta = value
            self.validate_volume_range(self.rx_delta)    # validate type volume_range
        value = find_attr_value_('tx_delta', node)
        if value is not None and 'tx_delta' not in already_processed:
            already_processed.add('tx_delta')
            self.tx_delta = value
            self.validate_volume_range(self.tx_delta)    # validate type volume_range
        value = find_attr_value_('cleardigits', node)
        if value is not None and 'cleardigits' not in already_processed:
            already_processed.add('cleardigits')
            self.cleardigits = value
            self.validate_boolean_type(self.cleardigits)    # validate type boolean_type
        value = find_attr_value_('info_ack_mode', node)
        if value is not None and 'info_ack_mode' not in already_processed:
            already_processed.add('info_ack_mode')
            self.info_ack_mode = value
            self.validate_ack_mode_option(self.info_ack_mode)    # validate type ack_mode_option
        value = find_attr_value_('hangup_ack_mode', node)
        if value is not None and 'hangup_ack_mode' not in already_processed:
            already_processed.add('hangup_ack_mode')
            self.hangup_ack_mode = value
            self.validate_ack_mode_option(self.hangup_ack_mode)    # validate type ack_mode_option
        value = find_attr_value_('early_media', node)
        if value is not None and 'early_media' not in already_processed:
            already_processed.add('early_media')
            self.early_media = value
            self.validate_boolean_type(self.early_media)    # validate type boolean_type
        value = find_attr_value_('audio', node)
        if value is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            self.audio = value
            self.validate_media_direction(self.audio)    # validate type media_direction
        value = find_attr_value_('video', node)
        if value is not None and 'video' not in already_processed:
            already_processed.add('video')
            self.video = value
            self.validate_media_direction(self.video)    # validate type media_direction
        value = find_attr_value_('message', node)
        if value is not None and 'message' not in already_processed:
            already_processed.add('message')
            self.message = value
            self.validate_media_direction(self.message)    # validate type media_direction
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_media_direction(self.image)    # validate type media_direction
        value = find_attr_value_('accept', node)
        if value is not None and 'accept' not in already_processed:
            already_processed.add('accept')
            self.accept = value
            self.validate_boolean_type(self.accept)    # validate type boolean_type
        value = find_attr_value_('async_completion', node)
        if value is not None and 'async_completion' not in already_processed:
            already_processed.add('async_completion')
            self.async_completion = value
            self.validate_boolean_type(self.async_completion)    # validate type boolean_type
        value = find_attr_value_('dial_timeout', node)
        if value is not None and 'dial_timeout' not in already_processed:
            already_processed.add('dial_timeout')
            self.dial_timeout = value
            self.validate_time_value(self.dial_timeout)    # validate type time_value
        value = find_attr_value_('encryption', node)
        if value is not None and 'encryption' not in already_processed:
            already_processed.add('encryption')
            self.encryption = value
            self.validate_rtp_encryption_option(self.encryption)    # validate type rtp_encryption_option
        value = find_attr_value_('ice', node)
        if value is not None and 'ice' not in already_processed:
            already_processed.add('ice')
            self.ice = value
            self.validate_boolean_type(self.ice)    # validate type boolean_type
        value = find_attr_value_('setup', node)
        if value is not None and 'setup' not in already_processed:
            already_processed.add('setup')
            self.setup = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('local_rtp_address', node)
        if value is not None and 'local_rtp_address' not in already_processed:
            already_processed.add('local_rtp_address')
            self.local_rtp_address = value
        value = find_attr_value_('answer_ack_mode', node)
        if value is not None and 'answer_ack_mode' not in already_processed:
            already_processed.add('answer_ack_mode')
            self.answer_ack_mode = value
            self.validate_ack_mode_option(self.answer_ack_mode)    # validate type ack_mode_option
        value = find_attr_value_('prack_mode', node)
        if value is not None and 'prack_mode' not in already_processed:
            already_processed.add('prack_mode')
            self.prack_mode = value
            self.validate_ack_mode_option(self.prack_mode)    # validate type ack_mode_option
        value = find_attr_value_('prack_ack_mode', node)
        if value is not None and 'prack_ack_mode' not in already_processed:
            already_processed.add('prack_ack_mode')
            self.prack_ack_mode = value
            self.validate_ack_mode_option(self.prack_ack_mode)    # validate type ack_mode_option
        value = find_attr_value_('prack_level', node)
        if value is not None and 'prack_level' not in already_processed:
            already_processed.add('prack_level')
            self.prack_level = value
        value = find_attr_value_('rtcp_feedback', node)
        if value is not None and 'rtcp_feedback' not in already_processed:
            already_processed.add('rtcp_feedback')
            self.rtcp_feedback = value
            self.validate_rtcp_feedback_mode_option(self.rtcp_feedback)    # validate type rtcp_feedback_mode_option
        value = find_attr_value_('local_events', node)
        if value is not None and 'local_events' not in already_processed:
            already_processed.add('local_events')
            self.local_events = value
        value = find_attr_value_('gusid', node)
        if value is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            self.gusid = value
        value = find_attr_value_('cpa_profile', node)
        if value is not None and 'cpa_profile' not in already_processed:
            already_processed.add('cpa_profile')
            self.cpa_profile = value
        value = find_attr_value_('codec_profile', node)
        if value is not None and 'codec_profile' not in already_processed:
            already_processed.add('codec_profile')
            self.codec_profile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'call_action':
            obj_ = call_action.factory()
            obj_.build(child_)
            self.call_action = obj_
            obj_.original_tagname_ = 'call_action'
        elif nodeName_ == 'sip_headers':
            obj_ = sip_headers.factory()
            obj_.build(child_)
            self.sip_headers = obj_
            obj_.original_tagname_ = 'sip_headers'
# end class call


class call_response(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, signaling=None, media=None, destination_uri=None, display_name=None, source_uri=None, called_uri=None, call_type=None, connected=None, sdp=None, cpa=None, dtmf_mode=None, async_dtmf=None, async_tone=None, rx_delta=None, tx_delta=None, cleardigits=None, info_ack_mode=None, hangup_ack_mode=None, early_media=None, audio=None, video=None, message=None, image=None, async_completion=None, encryption=None, ice=None, setup=None, content=None, content_type=None, local_rtp_address=None, answer_ack_mode=None, prack_mode=None, prack_ack_mode=None, prack_level=None, rtcp_feedback=None, local_events=None, remote_events=None, gusid=None, cpa_profile=None, codec_profile=None, href=None, identifier=None, appid=None, call_action=None, sip_headers=None):
        self.original_tagname_ = None
        self.signaling = _cast(None, signaling)
        self.media = _cast(None, media)
        self.destination_uri = _cast(None, destination_uri)
        self.display_name = _cast(None, display_name)
        self.source_uri = _cast(None, source_uri)
        self.called_uri = _cast(None, called_uri)
        self.call_type = _cast(None, call_type)
        self.connected = _cast(None, connected)
        self.sdp = _cast(None, sdp)
        self.cpa = _cast(None, cpa)
        self.dtmf_mode = _cast(None, dtmf_mode)
        self.async_dtmf = _cast(None, async_dtmf)
        self.async_tone = _cast(None, async_tone)
        self.rx_delta = _cast(None, rx_delta)
        self.tx_delta = _cast(None, tx_delta)
        self.cleardigits = _cast(None, cleardigits)
        self.info_ack_mode = _cast(None, info_ack_mode)
        self.hangup_ack_mode = _cast(None, hangup_ack_mode)
        self.early_media = _cast(None, early_media)
        self.audio = _cast(None, audio)
        self.video = _cast(None, video)
        self.message = _cast(None, message)
        self.image = _cast(None, image)
        self.async_completion = _cast(None, async_completion)
        self.encryption = _cast(None, encryption)
        self.ice = _cast(None, ice)
        self.setup = _cast(None, setup)
        self.content = _cast(None, content)
        self.content_type = _cast(None, content_type)
        self.local_rtp_address = _cast(None, local_rtp_address)
        self.answer_ack_mode = _cast(None, answer_ack_mode)
        self.prack_mode = _cast(None, prack_mode)
        self.prack_ack_mode = _cast(None, prack_ack_mode)
        self.prack_level = _cast(None, prack_level)
        self.rtcp_feedback = _cast(None, rtcp_feedback)
        self.local_events = _cast(None, local_events)
        self.remote_events = _cast(None, remote_events)
        self.gusid = _cast(None, gusid)
        self.cpa_profile = _cast(None, cpa_profile)
        self.codec_profile = _cast(None, codec_profile)
        self.href = _cast(None, href)
        self.identifier = _cast(None, identifier)
        self.appid = _cast(None, appid)
        self.call_action = call_action
        self.sip_headers = sip_headers
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, call_response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if call_response.subclass:
            return call_response.subclass(*args_, **kwargs_)
        else:
            return call_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_call_action(self): return self.call_action
    def set_call_action(self, call_action): self.call_action = call_action
    def get_sip_headers(self): return self.sip_headers
    def set_sip_headers(self, sip_headers): self.sip_headers = sip_headers
    def get_signaling(self): return self.signaling
    def set_signaling(self, signaling): self.signaling = signaling
    def get_media(self): return self.media
    def set_media(self, media): self.media = media
    def get_destination_uri(self): return self.destination_uri
    def set_destination_uri(self, destination_uri): self.destination_uri = destination_uri
    def get_display_name(self): return self.display_name
    def set_display_name(self, display_name): self.display_name = display_name
    def get_source_uri(self): return self.source_uri
    def set_source_uri(self, source_uri): self.source_uri = source_uri
    def get_called_uri(self): return self.called_uri
    def set_called_uri(self, called_uri): self.called_uri = called_uri
    def get_call_type(self): return self.call_type
    def set_call_type(self, call_type): self.call_type = call_type
    def get_connected(self): return self.connected
    def set_connected(self, connected): self.connected = connected
    def get_sdp(self): return self.sdp
    def set_sdp(self, sdp): self.sdp = sdp
    def get_cpa(self): return self.cpa
    def set_cpa(self, cpa): self.cpa = cpa
    def get_dtmf_mode(self): return self.dtmf_mode
    def set_dtmf_mode(self, dtmf_mode): self.dtmf_mode = dtmf_mode
    def get_async_dtmf(self): return self.async_dtmf
    def set_async_dtmf(self, async_dtmf): self.async_dtmf = async_dtmf
    def get_async_tone(self): return self.async_tone
    def set_async_tone(self, async_tone): self.async_tone = async_tone
    def get_rx_delta(self): return self.rx_delta
    def set_rx_delta(self, rx_delta): self.rx_delta = rx_delta
    def get_tx_delta(self): return self.tx_delta
    def set_tx_delta(self, tx_delta): self.tx_delta = tx_delta
    def get_cleardigits(self): return self.cleardigits
    def set_cleardigits(self, cleardigits): self.cleardigits = cleardigits
    def get_info_ack_mode(self): return self.info_ack_mode
    def set_info_ack_mode(self, info_ack_mode): self.info_ack_mode = info_ack_mode
    def get_hangup_ack_mode(self): return self.hangup_ack_mode
    def set_hangup_ack_mode(self, hangup_ack_mode): self.hangup_ack_mode = hangup_ack_mode
    def get_early_media(self): return self.early_media
    def set_early_media(self, early_media): self.early_media = early_media
    def get_audio(self): return self.audio
    def set_audio(self, audio): self.audio = audio
    def get_video(self): return self.video
    def set_video(self, video): self.video = video
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_image(self): return self.image
    def set_image(self, image): self.image = image
    def get_async_completion(self): return self.async_completion
    def set_async_completion(self, async_completion): self.async_completion = async_completion
    def get_encryption(self): return self.encryption
    def set_encryption(self, encryption): self.encryption = encryption
    def get_ice(self): return self.ice
    def set_ice(self, ice): self.ice = ice
    def get_setup(self): return self.setup
    def set_setup(self, setup): self.setup = setup
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_local_rtp_address(self): return self.local_rtp_address
    def set_local_rtp_address(self, local_rtp_address): self.local_rtp_address = local_rtp_address
    def get_answer_ack_mode(self): return self.answer_ack_mode
    def set_answer_ack_mode(self, answer_ack_mode): self.answer_ack_mode = answer_ack_mode
    def get_prack_mode(self): return self.prack_mode
    def set_prack_mode(self, prack_mode): self.prack_mode = prack_mode
    def get_prack_ack_mode(self): return self.prack_ack_mode
    def set_prack_ack_mode(self, prack_ack_mode): self.prack_ack_mode = prack_ack_mode
    def get_prack_level(self): return self.prack_level
    def set_prack_level(self, prack_level): self.prack_level = prack_level
    def get_rtcp_feedback(self): return self.rtcp_feedback
    def set_rtcp_feedback(self, rtcp_feedback): self.rtcp_feedback = rtcp_feedback
    def get_local_events(self): return self.local_events
    def set_local_events(self, local_events): self.local_events = local_events
    def get_remote_events(self): return self.remote_events
    def set_remote_events(self, remote_events): self.remote_events = remote_events
    def get_gusid(self): return self.gusid
    def set_gusid(self, gusid): self.gusid = gusid
    def get_cpa_profile(self): return self.cpa_profile
    def set_cpa_profile(self, cpa_profile): self.cpa_profile = cpa_profile
    def get_codec_profile(self): return self.codec_profile
    def set_codec_profile(self, codec_profile): self.codec_profile = codec_profile
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_appid(self): return self.appid
    def set_appid(self, appid): self.appid = appid
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def validate_media_type(self, value):
        # Validate type media_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio', 'video', 'audiovideo', 'message', 'image', 'unknown', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_type' % {"value" : value.encode("utf-8")} )
    def validate_call_type_option(self, value):
        # Validate type call_type_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inbound', 'outbound', '3pcc']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on call_type_option' % {"value" : value.encode("utf-8")} )
    def validate_dtmf_mode_option(self, value):
        # Validate type dtmf_mode_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inband', 'outofband', 'rfc2833']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on dtmf_mode_option' % {"value" : value.encode("utf-8")} )
    def validate_volume_range(self, value):
        # Validate type volume_range, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_volume_range_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_volume_range_patterns_, ))
    validate_volume_range_patterns_ = [['^((\\+$|^)([0-9]$|^1[0-9]$|^2[0-9]$|^3[0-1])$|^(\\-)([0-9]$|^1[0-9]$|^2[0-9]$|^3[0-2]))((dB$|^db$|^DB$|^Db)$|^(dB$|^db$|^DB$|^Db)(;)(relative$|^absolute))$']]
    def validate_ack_mode_option(self, value):
        # Validate type ack_mode_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['automatic', 'manual']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ack_mode_option' % {"value" : value.encode("utf-8")} )
    def validate_media_direction(self, value):
        # Validate type media_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inactive', 'sendonly', 'recvonly', 'sendrecv']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_direction' % {"value" : value.encode("utf-8")} )
    def validate_rtp_encryption_option(self, value):
        # Validate type rtp_encryption_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'dtls', 'srtp']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on rtp_encryption_option' % {"value" : value.encode("utf-8")} )
    def validate_rtcp_feedback_mode_option(self, value):
        # Validate type rtcp_feedback_mode_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio', 'video', 'audiovideo', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on rtcp_feedback_mode_option' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.call_action is not None or
            self.sip_headers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='call_response', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('call_response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='call_response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='call_response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='call_response'):
        if self.signaling is not None and 'signaling' not in already_processed:
            already_processed.add('signaling')
            outfile.write(' signaling=%s' % (quote_attrib(self.signaling), ))
        if self.media is not None and 'media' not in already_processed:
            already_processed.add('media')
            outfile.write(' media=%s' % (quote_attrib(self.media), ))
        if self.destination_uri is not None and 'destination_uri' not in already_processed:
            already_processed.add('destination_uri')
            outfile.write(' destination_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.destination_uri), input_name='destination_uri')), ))
        if self.display_name is not None and 'display_name' not in already_processed:
            already_processed.add('display_name')
            outfile.write(' display_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.display_name), input_name='display_name')), ))
        if self.source_uri is not None and 'source_uri' not in already_processed:
            already_processed.add('source_uri')
            outfile.write(' source_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source_uri), input_name='source_uri')), ))
        if self.called_uri is not None and 'called_uri' not in already_processed:
            already_processed.add('called_uri')
            outfile.write(' called_uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.called_uri), input_name='called_uri')), ))
        if self.call_type is not None and 'call_type' not in already_processed:
            already_processed.add('call_type')
            outfile.write(' call_type=%s' % (quote_attrib(self.call_type), ))
        if self.connected is not None and 'connected' not in already_processed:
            already_processed.add('connected')
            outfile.write(' connected=%s' % (quote_attrib(self.connected), ))
        if self.sdp is not None and 'sdp' not in already_processed:
            already_processed.add('sdp')
            outfile.write(' sdp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sdp), input_name='sdp')), ))
        if self.cpa is not None and 'cpa' not in already_processed:
            already_processed.add('cpa')
            outfile.write(' cpa=%s' % (quote_attrib(self.cpa), ))
        if self.dtmf_mode is not None and 'dtmf_mode' not in already_processed:
            already_processed.add('dtmf_mode')
            outfile.write(' dtmf_mode=%s' % (quote_attrib(self.dtmf_mode), ))
        if self.async_dtmf is not None and 'async_dtmf' not in already_processed:
            already_processed.add('async_dtmf')
            outfile.write(' async_dtmf=%s' % (quote_attrib(self.async_dtmf), ))
        if self.async_tone is not None and 'async_tone' not in already_processed:
            already_processed.add('async_tone')
            outfile.write(' async_tone=%s' % (quote_attrib(self.async_tone), ))
        if self.rx_delta is not None and 'rx_delta' not in already_processed:
            already_processed.add('rx_delta')
            outfile.write(' rx_delta=%s' % (quote_attrib(self.rx_delta), ))
        if self.tx_delta is not None and 'tx_delta' not in already_processed:
            already_processed.add('tx_delta')
            outfile.write(' tx_delta=%s' % (quote_attrib(self.tx_delta), ))
        if self.cleardigits is not None and 'cleardigits' not in already_processed:
            already_processed.add('cleardigits')
            outfile.write(' cleardigits=%s' % (quote_attrib(self.cleardigits), ))
        if self.info_ack_mode is not None and 'info_ack_mode' not in already_processed:
            already_processed.add('info_ack_mode')
            outfile.write(' info_ack_mode=%s' % (quote_attrib(self.info_ack_mode), ))
        if self.hangup_ack_mode is not None and 'hangup_ack_mode' not in already_processed:
            already_processed.add('hangup_ack_mode')
            outfile.write(' hangup_ack_mode=%s' % (quote_attrib(self.hangup_ack_mode), ))
        if self.early_media is not None and 'early_media' not in already_processed:
            already_processed.add('early_media')
            outfile.write(' early_media=%s' % (quote_attrib(self.early_media), ))
        if self.audio is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            outfile.write(' audio=%s' % (quote_attrib(self.audio), ))
        if self.video is not None and 'video' not in already_processed:
            already_processed.add('video')
            outfile.write(' video=%s' % (quote_attrib(self.video), ))
        if self.message is not None and 'message' not in already_processed:
            already_processed.add('message')
            outfile.write(' message=%s' % (quote_attrib(self.message), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (quote_attrib(self.image), ))
        if self.async_completion is not None and 'async_completion' not in already_processed:
            already_processed.add('async_completion')
            outfile.write(' async_completion=%s' % (quote_attrib(self.async_completion), ))
        if self.encryption is not None and 'encryption' not in already_processed:
            already_processed.add('encryption')
            outfile.write(' encryption=%s' % (quote_attrib(self.encryption), ))
        if self.ice is not None and 'ice' not in already_processed:
            already_processed.add('ice')
            outfile.write(' ice=%s' % (quote_attrib(self.ice), ))
        if self.setup is not None and 'setup' not in already_processed:
            already_processed.add('setup')
            outfile.write(' setup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.setup), input_name='setup')), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content_type), input_name='content_type')), ))
        if self.local_rtp_address is not None and 'local_rtp_address' not in already_processed:
            already_processed.add('local_rtp_address')
            outfile.write(' local_rtp_address=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.local_rtp_address), input_name='local_rtp_address')), ))
        if self.answer_ack_mode is not None and 'answer_ack_mode' not in already_processed:
            already_processed.add('answer_ack_mode')
            outfile.write(' answer_ack_mode=%s' % (quote_attrib(self.answer_ack_mode), ))
        if self.prack_mode is not None and 'prack_mode' not in already_processed:
            already_processed.add('prack_mode')
            outfile.write(' prack_mode=%s' % (quote_attrib(self.prack_mode), ))
        if self.prack_ack_mode is not None and 'prack_ack_mode' not in already_processed:
            already_processed.add('prack_ack_mode')
            outfile.write(' prack_ack_mode=%s' % (quote_attrib(self.prack_ack_mode), ))
        if self.prack_level is not None and 'prack_level' not in already_processed:
            already_processed.add('prack_level')
            outfile.write(' prack_level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prack_level), input_name='prack_level')), ))
        if self.rtcp_feedback is not None and 'rtcp_feedback' not in already_processed:
            already_processed.add('rtcp_feedback')
            outfile.write(' rtcp_feedback=%s' % (quote_attrib(self.rtcp_feedback), ))
        if self.local_events is not None and 'local_events' not in already_processed:
            already_processed.add('local_events')
            outfile.write(' local_events=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.local_events), input_name='local_events')), ))
        if self.remote_events is not None and 'remote_events' not in already_processed:
            already_processed.add('remote_events')
            outfile.write(' remote_events=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.remote_events), input_name='remote_events')), ))
        if self.gusid is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            outfile.write(' gusid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gusid), input_name='gusid')), ))
        if self.cpa_profile is not None and 'cpa_profile' not in already_processed:
            already_processed.add('cpa_profile')
            outfile.write(' cpa_profile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cpa_profile), input_name='cpa_profile')), ))
        if self.codec_profile is not None and 'codec_profile' not in already_processed:
            already_processed.add('codec_profile')
            outfile.write(' codec_profile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codec_profile), input_name='codec_profile')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.identifier is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            outfile.write(' identifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.identifier), input_name='identifier')), ))
        if self.appid is not None and 'appid' not in already_processed:
            already_processed.add('appid')
            outfile.write(' appid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.appid), input_name='appid')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='call_response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.call_action is not None:
            self.call_action.export(outfile, level, namespace_, name_='call_action', pretty_print=pretty_print)
        if self.sip_headers is not None:
            self.sip_headers.export(outfile, level, namespace_, name_='sip_headers', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('signaling', node)
        if value is not None and 'signaling' not in already_processed:
            already_processed.add('signaling')
            self.signaling = value
            self.validate_boolean_type(self.signaling)    # validate type boolean_type
        value = find_attr_value_('media', node)
        if value is not None and 'media' not in already_processed:
            already_processed.add('media')
            self.media = value
            self.validate_media_type(self.media)    # validate type media_type
        value = find_attr_value_('destination_uri', node)
        if value is not None and 'destination_uri' not in already_processed:
            already_processed.add('destination_uri')
            self.destination_uri = value
        value = find_attr_value_('display_name', node)
        if value is not None and 'display_name' not in already_processed:
            already_processed.add('display_name')
            self.display_name = value
        value = find_attr_value_('source_uri', node)
        if value is not None and 'source_uri' not in already_processed:
            already_processed.add('source_uri')
            self.source_uri = value
        value = find_attr_value_('called_uri', node)
        if value is not None and 'called_uri' not in already_processed:
            already_processed.add('called_uri')
            self.called_uri = value
        value = find_attr_value_('call_type', node)
        if value is not None and 'call_type' not in already_processed:
            already_processed.add('call_type')
            self.call_type = value
            self.validate_call_type_option(self.call_type)    # validate type call_type_option
        value = find_attr_value_('connected', node)
        if value is not None and 'connected' not in already_processed:
            already_processed.add('connected')
            self.connected = value
            self.validate_boolean_type(self.connected)    # validate type boolean_type
        value = find_attr_value_('sdp', node)
        if value is not None and 'sdp' not in already_processed:
            already_processed.add('sdp')
            self.sdp = value
        value = find_attr_value_('cpa', node)
        if value is not None and 'cpa' not in already_processed:
            already_processed.add('cpa')
            self.cpa = value
            self.validate_boolean_type(self.cpa)    # validate type boolean_type
        value = find_attr_value_('dtmf_mode', node)
        if value is not None and 'dtmf_mode' not in already_processed:
            already_processed.add('dtmf_mode')
            self.dtmf_mode = value
            self.validate_dtmf_mode_option(self.dtmf_mode)    # validate type dtmf_mode_option
        value = find_attr_value_('async_dtmf', node)
        if value is not None and 'async_dtmf' not in already_processed:
            already_processed.add('async_dtmf')
            self.async_dtmf = value
            self.validate_boolean_type(self.async_dtmf)    # validate type boolean_type
        value = find_attr_value_('async_tone', node)
        if value is not None and 'async_tone' not in already_processed:
            already_processed.add('async_tone')
            self.async_tone = value
            self.validate_boolean_type(self.async_tone)    # validate type boolean_type
        value = find_attr_value_('rx_delta', node)
        if value is not None and 'rx_delta' not in already_processed:
            already_processed.add('rx_delta')
            self.rx_delta = value
            self.validate_volume_range(self.rx_delta)    # validate type volume_range
        value = find_attr_value_('tx_delta', node)
        if value is not None and 'tx_delta' not in already_processed:
            already_processed.add('tx_delta')
            self.tx_delta = value
            self.validate_volume_range(self.tx_delta)    # validate type volume_range
        value = find_attr_value_('cleardigits', node)
        if value is not None and 'cleardigits' not in already_processed:
            already_processed.add('cleardigits')
            self.cleardigits = value
            self.validate_boolean_type(self.cleardigits)    # validate type boolean_type
        value = find_attr_value_('info_ack_mode', node)
        if value is not None and 'info_ack_mode' not in already_processed:
            already_processed.add('info_ack_mode')
            self.info_ack_mode = value
            self.validate_ack_mode_option(self.info_ack_mode)    # validate type ack_mode_option
        value = find_attr_value_('hangup_ack_mode', node)
        if value is not None and 'hangup_ack_mode' not in already_processed:
            already_processed.add('hangup_ack_mode')
            self.hangup_ack_mode = value
            self.validate_ack_mode_option(self.hangup_ack_mode)    # validate type ack_mode_option
        value = find_attr_value_('early_media', node)
        if value is not None and 'early_media' not in already_processed:
            already_processed.add('early_media')
            self.early_media = value
            self.validate_boolean_type(self.early_media)    # validate type boolean_type
        value = find_attr_value_('audio', node)
        if value is not None and 'audio' not in already_processed:
            already_processed.add('audio')
            self.audio = value
            self.validate_media_direction(self.audio)    # validate type media_direction
        value = find_attr_value_('video', node)
        if value is not None and 'video' not in already_processed:
            already_processed.add('video')
            self.video = value
            self.validate_media_direction(self.video)    # validate type media_direction
        value = find_attr_value_('message', node)
        if value is not None and 'message' not in already_processed:
            already_processed.add('message')
            self.message = value
            self.validate_media_direction(self.message)    # validate type media_direction
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_media_direction(self.image)    # validate type media_direction
        value = find_attr_value_('async_completion', node)
        if value is not None and 'async_completion' not in already_processed:
            already_processed.add('async_completion')
            self.async_completion = value
            self.validate_boolean_type(self.async_completion)    # validate type boolean_type
        value = find_attr_value_('encryption', node)
        if value is not None and 'encryption' not in already_processed:
            already_processed.add('encryption')
            self.encryption = value
            self.validate_rtp_encryption_option(self.encryption)    # validate type rtp_encryption_option
        value = find_attr_value_('ice', node)
        if value is not None and 'ice' not in already_processed:
            already_processed.add('ice')
            self.ice = value
            self.validate_boolean_type(self.ice)    # validate type boolean_type
        value = find_attr_value_('setup', node)
        if value is not None and 'setup' not in already_processed:
            already_processed.add('setup')
            self.setup = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('local_rtp_address', node)
        if value is not None and 'local_rtp_address' not in already_processed:
            already_processed.add('local_rtp_address')
            self.local_rtp_address = value
        value = find_attr_value_('answer_ack_mode', node)
        if value is not None and 'answer_ack_mode' not in already_processed:
            already_processed.add('answer_ack_mode')
            self.answer_ack_mode = value
            self.validate_ack_mode_option(self.answer_ack_mode)    # validate type ack_mode_option
        value = find_attr_value_('prack_mode', node)
        if value is not None and 'prack_mode' not in already_processed:
            already_processed.add('prack_mode')
            self.prack_mode = value
            self.validate_ack_mode_option(self.prack_mode)    # validate type ack_mode_option
        value = find_attr_value_('prack_ack_mode', node)
        if value is not None and 'prack_ack_mode' not in already_processed:
            already_processed.add('prack_ack_mode')
            self.prack_ack_mode = value
            self.validate_ack_mode_option(self.prack_ack_mode)    # validate type ack_mode_option
        value = find_attr_value_('prack_level', node)
        if value is not None and 'prack_level' not in already_processed:
            already_processed.add('prack_level')
            self.prack_level = value
        value = find_attr_value_('rtcp_feedback', node)
        if value is not None and 'rtcp_feedback' not in already_processed:
            already_processed.add('rtcp_feedback')
            self.rtcp_feedback = value
            self.validate_rtcp_feedback_mode_option(self.rtcp_feedback)    # validate type rtcp_feedback_mode_option
        value = find_attr_value_('local_events', node)
        if value is not None and 'local_events' not in already_processed:
            already_processed.add('local_events')
            self.local_events = value
        value = find_attr_value_('remote_events', node)
        if value is not None and 'remote_events' not in already_processed:
            already_processed.add('remote_events')
            self.remote_events = value
        value = find_attr_value_('gusid', node)
        if value is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            self.gusid = value
        value = find_attr_value_('cpa_profile', node)
        if value is not None and 'cpa_profile' not in already_processed:
            already_processed.add('cpa_profile')
            self.cpa_profile = value
        value = find_attr_value_('codec_profile', node)
        if value is not None and 'codec_profile' not in already_processed:
            already_processed.add('codec_profile')
            self.codec_profile = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('identifier', node)
        if value is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            self.identifier = value
        value = find_attr_value_('appid', node)
        if value is not None and 'appid' not in already_processed:
            already_processed.add('appid')
            self.appid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'call_action':
            obj_ = call_action.factory()
            obj_.build(child_)
            self.call_action = obj_
            obj_.original_tagname_ = 'call_action'
        elif nodeName_ == 'sip_headers':
            obj_ = sip_headers.factory()
            obj_.build(child_)
            self.sip_headers = obj_
            obj_.original_tagname_ = 'sip_headers'
# end class call_response


class calls_response(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, size=None, call_response=None):
        self.original_tagname_ = None
        self.size = _cast(None, size)
        if call_response is None:
            self.call_response = []
        else:
            self.call_response = call_response
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, calls_response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if calls_response.subclass:
            return calls_response.subclass(*args_, **kwargs_)
        else:
            return calls_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_call_response(self): return self.call_response
    def set_call_response(self, call_response): self.call_response = call_response
    def add_call_response(self, value): self.call_response.append(value)
    def insert_call_response_at(self, index, value): self.call_response.insert(index, value)
    def replace_call_response_at(self, index, value): self.call_response[index] = value
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.call_response
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='calls_response', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('calls_response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='calls_response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='calls_response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='calls_response'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='calls_response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for call_response_ in self.call_response:
            call_response_.export(outfile, level, namespace_, name_='call_response', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'call_response':
            obj_ = call_response.factory()
            obj_.build(child_)
            self.call_response.append(obj_)
            obj_.original_tagname_ = 'call_response'
# end class calls_response


class eventhandler(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, eventsubscribe=None):
        self.original_tagname_ = None
        if eventsubscribe is None:
            self.eventsubscribe = []
        else:
            self.eventsubscribe = eventsubscribe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eventhandler)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eventhandler.subclass:
            return eventhandler.subclass(*args_, **kwargs_)
        else:
            return eventhandler(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventsubscribe(self): return self.eventsubscribe
    def set_eventsubscribe(self, eventsubscribe): self.eventsubscribe = eventsubscribe
    def add_eventsubscribe(self, value): self.eventsubscribe.append(value)
    def insert_eventsubscribe_at(self, index, value): self.eventsubscribe.insert(index, value)
    def replace_eventsubscribe_at(self, index, value): self.eventsubscribe[index] = value
    def hasContent_(self):
        if (
            self.eventsubscribe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='eventhandler', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eventhandler')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eventhandler')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='eventhandler', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='eventhandler'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='eventhandler', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for eventsubscribe_ in self.eventsubscribe:
            eventsubscribe_.export(outfile, level, namespace_, name_='eventsubscribe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eventsubscribe':
            obj_ = eventsubscribe.factory()
            obj_.build(child_)
            self.eventsubscribe.append(obj_)
            obj_.original_tagname_ = 'eventsubscribe'
# end class eventhandler


class eventhandler_response(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, href=None, identifier=None, appid=None, eventsubscribe=None):
        self.original_tagname_ = None
        self.href = _cast(None, href)
        self.identifier = _cast(None, identifier)
        self.appid = _cast(None, appid)
        if eventsubscribe is None:
            self.eventsubscribe = []
        else:
            self.eventsubscribe = eventsubscribe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eventhandler_response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eventhandler_response.subclass:
            return eventhandler_response.subclass(*args_, **kwargs_)
        else:
            return eventhandler_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventsubscribe(self): return self.eventsubscribe
    def set_eventsubscribe(self, eventsubscribe): self.eventsubscribe = eventsubscribe
    def add_eventsubscribe(self, value): self.eventsubscribe.append(value)
    def insert_eventsubscribe_at(self, index, value): self.eventsubscribe.insert(index, value)
    def replace_eventsubscribe_at(self, index, value): self.eventsubscribe[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_appid(self): return self.appid
    def set_appid(self, appid): self.appid = appid
    def hasContent_(self):
        if (
            self.eventsubscribe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='eventhandler_response', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eventhandler_response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eventhandler_response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='eventhandler_response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='eventhandler_response'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.identifier is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            outfile.write(' identifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.identifier), input_name='identifier')), ))
        if self.appid is not None and 'appid' not in already_processed:
            already_processed.add('appid')
            outfile.write(' appid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.appid), input_name='appid')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='eventhandler_response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for eventsubscribe_ in self.eventsubscribe:
            eventsubscribe_.export(outfile, level, namespace_, name_='eventsubscribe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('identifier', node)
        if value is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            self.identifier = value
        value = find_attr_value_('appid', node)
        if value is not None and 'appid' not in already_processed:
            already_processed.add('appid')
            self.appid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eventsubscribe':
            obj_ = eventsubscribe.factory()
            obj_.build(child_)
            self.eventsubscribe.append(obj_)
            obj_.original_tagname_ = 'eventsubscribe'
# end class eventhandler_response


class eventhandlers_response(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, size=None, eventhandler_response=None):
        self.original_tagname_ = None
        self.size = _cast(None, size)
        if eventhandler_response is None:
            self.eventhandler_response = []
        else:
            self.eventhandler_response = eventhandler_response
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eventhandlers_response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eventhandlers_response.subclass:
            return eventhandlers_response.subclass(*args_, **kwargs_)
        else:
            return eventhandlers_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventhandler_response(self): return self.eventhandler_response
    def set_eventhandler_response(self, eventhandler_response): self.eventhandler_response = eventhandler_response
    def add_eventhandler_response(self, value): self.eventhandler_response.append(value)
    def insert_eventhandler_response_at(self, index, value): self.eventhandler_response.insert(index, value)
    def replace_eventhandler_response_at(self, index, value): self.eventhandler_response[index] = value
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.eventhandler_response
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='eventhandlers_response', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eventhandlers_response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eventhandlers_response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='eventhandlers_response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='eventhandlers_response'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='eventhandlers_response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for eventhandler_response_ in self.eventhandler_response:
            eventhandler_response_.export(outfile, level, namespace_, name_='eventhandler_response', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eventhandler_response':
            obj_ = eventhandler_response.factory()
            obj_.build(child_)
            self.eventhandler_response.append(obj_)
            obj_.original_tagname_ = 'eventhandler_response'
# end class eventhandlers_response


class eventsubscribe(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_='any', action='add', resource_id='any', resource_type='any'):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.action = _cast(None, action)
        self.resource_id = _cast(None, resource_id)
        self.resource_type = _cast(None, resource_type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eventsubscribe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eventsubscribe.subclass:
            return eventsubscribe.subclass(*args_, **kwargs_)
        else:
            return eventsubscribe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_resource_id(self): return self.resource_id
    def set_resource_id(self, resource_id): self.resource_id = resource_id
    def get_resource_type(self): return self.resource_type
    def set_resource_type(self, resource_type): self.resource_type = resource_type
    def validate_event_type(self, value):
        # Validate type event_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['end_play', 'end_record', 'end_playcollect', 'end_playrecord', 'end_overlay', 'end_dtmf', 'keepalive', 'incoming', 'ringing', 'connected', 'hangup', 'info', 'dtmf', 'tone', 'any', 'end_speak', 'start_of_input', 'end_recognize', 'answered', 'accepted', 'updated', 'active_talker', 'alarm', 'prack', 'conf_overlay_expired', 'message', 'end_send_message', 'stream', 'speech_marker', 'start_play', 'end_event', 'progress', 'prack_ack', 'status', 'info_ack', 'media_started', 'end_transfer', 'cpa']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on event_type' % {"value" : value.encode("utf-8")} )
    def validate_action_option(self, value):
        # Validate type action_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'remove']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on action_option' % {"value" : value.encode("utf-8")} )
    def validate_event_resource_type(self, value):
        # Validate type event_resource_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['call', 'conference', 'mrcp', 'any']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on event_resource_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='eventsubscribe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eventsubscribe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eventsubscribe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='eventsubscribe', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='eventsubscribe'):
        if self.type_ != "any" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.action != "add" and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.resource_id != "any" and 'resource_id' not in already_processed:
            already_processed.add('resource_id')
            outfile.write(' resource_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.resource_id), input_name='resource_id')), ))
        if self.resource_type != "any" and 'resource_type' not in already_processed:
            already_processed.add('resource_type')
            outfile.write(' resource_type=%s' % (quote_attrib(self.resource_type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='eventsubscribe', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_event_type(self.type_)    # validate type event_type
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
            self.validate_action_option(self.action)    # validate type action_option
        value = find_attr_value_('resource_id', node)
        if value is not None and 'resource_id' not in already_processed:
            already_processed.add('resource_id')
            self.resource_id = value
        value = find_attr_value_('resource_type', node)
        if value is not None and 'resource_type' not in already_processed:
            already_processed.add('resource_type')
            self.resource_type = value
            self.validate_event_resource_type(self.resource_type)    # validate type event_resource_type
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class eventsubscribe


class conference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mixing_mode='mcu', type_='audio', max_parties='9', reserve='0', layout=None, layout_regions=None, layout_size=None, orientation=None, aspect_ratio_mode=None, caption='yes', caption_duration='20s', beep='yes', clamp_dtmf='yes', auto_gain_control='yes', echo_cancellation='yes', active_talker_region=None, active_talker_interval=None, max_active_talkers=None, region_overlays=None, layout_bgcolor=None, layout_bgimage=None, primary_video_source=None, gusid=None, conf_action=None):
        self.original_tagname_ = None
        self.mixing_mode = _cast(None, mixing_mode)
        self.type_ = _cast(None, type_)
        self.max_parties = _cast(None, max_parties)
        self.reserve = _cast(None, reserve)
        self.layout = _cast(None, layout)
        self.layout_regions = _cast(None, layout_regions)
        self.layout_size = _cast(None, layout_size)
        self.orientation = _cast(None, orientation)
        self.aspect_ratio_mode = _cast(None, aspect_ratio_mode)
        self.caption = _cast(None, caption)
        self.caption_duration = _cast(None, caption_duration)
        self.beep = _cast(None, beep)
        self.clamp_dtmf = _cast(None, clamp_dtmf)
        self.auto_gain_control = _cast(None, auto_gain_control)
        self.echo_cancellation = _cast(None, echo_cancellation)
        self.active_talker_region = _cast(None, active_talker_region)
        self.active_talker_interval = _cast(None, active_talker_interval)
        self.max_active_talkers = _cast(None, max_active_talkers)
        self.region_overlays = _cast(None, region_overlays)
        self.layout_bgcolor = _cast(None, layout_bgcolor)
        self.layout_bgimage = _cast(None, layout_bgimage)
        self.primary_video_source = _cast(None, primary_video_source)
        self.gusid = _cast(None, gusid)
        self.conf_action = conf_action
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, conference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if conference.subclass:
            return conference.subclass(*args_, **kwargs_)
        else:
            return conference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_conf_action(self): return self.conf_action
    def set_conf_action(self, conf_action): self.conf_action = conf_action
    def get_mixing_mode(self): return self.mixing_mode
    def set_mixing_mode(self, mixing_mode): self.mixing_mode = mixing_mode
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_max_parties(self): return self.max_parties
    def set_max_parties(self, max_parties): self.max_parties = max_parties
    def get_reserve(self): return self.reserve
    def set_reserve(self, reserve): self.reserve = reserve
    def get_layout(self): return self.layout
    def set_layout(self, layout): self.layout = layout
    def get_layout_regions(self): return self.layout_regions
    def set_layout_regions(self, layout_regions): self.layout_regions = layout_regions
    def get_layout_size(self): return self.layout_size
    def set_layout_size(self, layout_size): self.layout_size = layout_size
    def get_orientation(self): return self.orientation
    def set_orientation(self, orientation): self.orientation = orientation
    def get_aspect_ratio_mode(self): return self.aspect_ratio_mode
    def set_aspect_ratio_mode(self, aspect_ratio_mode): self.aspect_ratio_mode = aspect_ratio_mode
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_caption_duration(self): return self.caption_duration
    def set_caption_duration(self, caption_duration): self.caption_duration = caption_duration
    def get_beep(self): return self.beep
    def set_beep(self, beep): self.beep = beep
    def get_clamp_dtmf(self): return self.clamp_dtmf
    def set_clamp_dtmf(self, clamp_dtmf): self.clamp_dtmf = clamp_dtmf
    def get_auto_gain_control(self): return self.auto_gain_control
    def set_auto_gain_control(self, auto_gain_control): self.auto_gain_control = auto_gain_control
    def get_echo_cancellation(self): return self.echo_cancellation
    def set_echo_cancellation(self, echo_cancellation): self.echo_cancellation = echo_cancellation
    def get_active_talker_region(self): return self.active_talker_region
    def set_active_talker_region(self, active_talker_region): self.active_talker_region = active_talker_region
    def get_active_talker_interval(self): return self.active_talker_interval
    def set_active_talker_interval(self, active_talker_interval): self.active_talker_interval = active_talker_interval
    def get_max_active_talkers(self): return self.max_active_talkers
    def set_max_active_talkers(self, max_active_talkers): self.max_active_talkers = max_active_talkers
    def get_region_overlays(self): return self.region_overlays
    def set_region_overlays(self, region_overlays): self.region_overlays = region_overlays
    def get_layout_bgcolor(self): return self.layout_bgcolor
    def set_layout_bgcolor(self, layout_bgcolor): self.layout_bgcolor = layout_bgcolor
    def get_layout_bgimage(self): return self.layout_bgimage
    def set_layout_bgimage(self, layout_bgimage): self.layout_bgimage = layout_bgimage
    def get_primary_video_source(self): return self.primary_video_source
    def set_primary_video_source(self, primary_video_source): self.primary_video_source = primary_video_source
    def get_gusid(self): return self.gusid
    def set_gusid(self, gusid): self.gusid = gusid
    def validate_conf_mixing_mode(self, value):
        # Validate type conf_mixing_mode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['mcu', 'sfu']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on conf_mixing_mode' % {"value" : value.encode("utf-8")} )
    def validate_media_type(self, value):
        # Validate type media_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio', 'video', 'audiovideo', 'message', 'image', 'unknown', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_type' % {"value" : value.encode("utf-8")} )
    def validate_layout_size_option(self, value):
        # Validate type layout_size_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['automatic', 'qcif', 'cif', 'vga', '720p']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on layout_size_option' % {"value" : value.encode("utf-8")} )
    def validate_orientation_option(self, value):
        # Validate type orientation_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['landscape', 'portrait']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on orientation_option' % {"value" : value.encode("utf-8")} )
    def validate_aspect_ratio_mode_option(self, value):
        # Validate type aspect_ratio_mode_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fill', 'fit', 'crop', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on aspect_ratio_mode_option' % {"value" : value.encode("utf-8")} )
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def hasContent_(self):
        if (
            self.conf_action is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conference', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('conference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conference'):
        if self.mixing_mode != "mcu" and 'mixing_mode' not in already_processed:
            already_processed.add('mixing_mode')
            outfile.write(' mixing_mode=%s' % (quote_attrib(self.mixing_mode), ))
        if self.type_ != "audio" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.max_parties != "9" and 'max_parties' not in already_processed:
            already_processed.add('max_parties')
            outfile.write(' max_parties=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.max_parties), input_name='max_parties')), ))
        if self.reserve != "0" and 'reserve' not in already_processed:
            already_processed.add('reserve')
            outfile.write(' reserve=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reserve), input_name='reserve')), ))
        if self.layout is not None and 'layout' not in already_processed:
            already_processed.add('layout')
            outfile.write(' layout=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.layout), input_name='layout')), ))
        if self.layout_regions is not None and 'layout_regions' not in already_processed:
            already_processed.add('layout_regions')
            outfile.write(' layout_regions=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.layout_regions), input_name='layout_regions')), ))
        if self.layout_size is not None and 'layout_size' not in already_processed:
            already_processed.add('layout_size')
            outfile.write(' layout_size=%s' % (quote_attrib(self.layout_size), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (quote_attrib(self.orientation), ))
        if self.aspect_ratio_mode is not None and 'aspect_ratio_mode' not in already_processed:
            already_processed.add('aspect_ratio_mode')
            outfile.write(' aspect_ratio_mode=%s' % (quote_attrib(self.aspect_ratio_mode), ))
        if self.caption != "yes" and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (quote_attrib(self.caption), ))
        if self.caption_duration != "20s" and 'caption_duration' not in already_processed:
            already_processed.add('caption_duration')
            outfile.write(' caption_duration=%s' % (quote_attrib(self.caption_duration), ))
        if self.beep != "yes" and 'beep' not in already_processed:
            already_processed.add('beep')
            outfile.write(' beep=%s' % (quote_attrib(self.beep), ))
        if self.clamp_dtmf != "yes" and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            outfile.write(' clamp_dtmf=%s' % (quote_attrib(self.clamp_dtmf), ))
        if self.auto_gain_control != "yes" and 'auto_gain_control' not in already_processed:
            already_processed.add('auto_gain_control')
            outfile.write(' auto_gain_control=%s' % (quote_attrib(self.auto_gain_control), ))
        if self.echo_cancellation != "yes" and 'echo_cancellation' not in already_processed:
            already_processed.add('echo_cancellation')
            outfile.write(' echo_cancellation=%s' % (quote_attrib(self.echo_cancellation), ))
        if self.active_talker_region is not None and 'active_talker_region' not in already_processed:
            already_processed.add('active_talker_region')
            outfile.write(' active_talker_region=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.active_talker_region), input_name='active_talker_region')), ))
        if self.active_talker_interval is not None and 'active_talker_interval' not in already_processed:
            already_processed.add('active_talker_interval')
            outfile.write(' active_talker_interval=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.active_talker_interval), input_name='active_talker_interval')), ))
        if self.max_active_talkers is not None and 'max_active_talkers' not in already_processed:
            already_processed.add('max_active_talkers')
            outfile.write(' max_active_talkers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.max_active_talkers), input_name='max_active_talkers')), ))
        if self.region_overlays is not None and 'region_overlays' not in already_processed:
            already_processed.add('region_overlays')
            outfile.write(' region_overlays=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.region_overlays), input_name='region_overlays')), ))
        if self.layout_bgcolor is not None and 'layout_bgcolor' not in already_processed:
            already_processed.add('layout_bgcolor')
            outfile.write(' layout_bgcolor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.layout_bgcolor), input_name='layout_bgcolor')), ))
        if self.layout_bgimage is not None and 'layout_bgimage' not in already_processed:
            already_processed.add('layout_bgimage')
            outfile.write(' layout_bgimage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.layout_bgimage), input_name='layout_bgimage')), ))
        if self.primary_video_source is not None and 'primary_video_source' not in already_processed:
            already_processed.add('primary_video_source')
            outfile.write(' primary_video_source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.primary_video_source), input_name='primary_video_source')), ))
        if self.gusid is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            outfile.write(' gusid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gusid), input_name='gusid')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='conference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.conf_action is not None:
            self.conf_action.export(outfile, level, namespace_, name_='conf_action', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mixing_mode', node)
        if value is not None and 'mixing_mode' not in already_processed:
            already_processed.add('mixing_mode')
            self.mixing_mode = value
            self.validate_conf_mixing_mode(self.mixing_mode)    # validate type conf_mixing_mode
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_media_type(self.type_)    # validate type media_type
        value = find_attr_value_('max_parties', node)
        if value is not None and 'max_parties' not in already_processed:
            already_processed.add('max_parties')
            self.max_parties = value
        value = find_attr_value_('reserve', node)
        if value is not None and 'reserve' not in already_processed:
            already_processed.add('reserve')
            self.reserve = value
        value = find_attr_value_('layout', node)
        if value is not None and 'layout' not in already_processed:
            already_processed.add('layout')
            self.layout = value
        value = find_attr_value_('layout_regions', node)
        if value is not None and 'layout_regions' not in already_processed:
            already_processed.add('layout_regions')
            self.layout_regions = value
        value = find_attr_value_('layout_size', node)
        if value is not None and 'layout_size' not in already_processed:
            already_processed.add('layout_size')
            self.layout_size = value
            self.validate_layout_size_option(self.layout_size)    # validate type layout_size_option
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_orientation_option(self.orientation)    # validate type orientation_option
        value = find_attr_value_('aspect_ratio_mode', node)
        if value is not None and 'aspect_ratio_mode' not in already_processed:
            already_processed.add('aspect_ratio_mode')
            self.aspect_ratio_mode = value
            self.validate_aspect_ratio_mode_option(self.aspect_ratio_mode)    # validate type aspect_ratio_mode_option
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
            self.validate_boolean_type(self.caption)    # validate type boolean_type
        value = find_attr_value_('caption_duration', node)
        if value is not None and 'caption_duration' not in already_processed:
            already_processed.add('caption_duration')
            self.caption_duration = value
            self.validate_time_value(self.caption_duration)    # validate type time_value
        value = find_attr_value_('beep', node)
        if value is not None and 'beep' not in already_processed:
            already_processed.add('beep')
            self.beep = value
            self.validate_boolean_type(self.beep)    # validate type boolean_type
        value = find_attr_value_('clamp_dtmf', node)
        if value is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            self.clamp_dtmf = value
            self.validate_boolean_type(self.clamp_dtmf)    # validate type boolean_type
        value = find_attr_value_('auto_gain_control', node)
        if value is not None and 'auto_gain_control' not in already_processed:
            already_processed.add('auto_gain_control')
            self.auto_gain_control = value
            self.validate_boolean_type(self.auto_gain_control)    # validate type boolean_type
        value = find_attr_value_('echo_cancellation', node)
        if value is not None and 'echo_cancellation' not in already_processed:
            already_processed.add('echo_cancellation')
            self.echo_cancellation = value
            self.validate_boolean_type(self.echo_cancellation)    # validate type boolean_type
        value = find_attr_value_('active_talker_region', node)
        if value is not None and 'active_talker_region' not in already_processed:
            already_processed.add('active_talker_region')
            self.active_talker_region = value
        value = find_attr_value_('active_talker_interval', node)
        if value is not None and 'active_talker_interval' not in already_processed:
            already_processed.add('active_talker_interval')
            self.active_talker_interval = value
        value = find_attr_value_('max_active_talkers', node)
        if value is not None and 'max_active_talkers' not in already_processed:
            already_processed.add('max_active_talkers')
            self.max_active_talkers = value
        value = find_attr_value_('region_overlays', node)
        if value is not None and 'region_overlays' not in already_processed:
            already_processed.add('region_overlays')
            self.region_overlays = value
        value = find_attr_value_('layout_bgcolor', node)
        if value is not None and 'layout_bgcolor' not in already_processed:
            already_processed.add('layout_bgcolor')
            self.layout_bgcolor = value
        value = find_attr_value_('layout_bgimage', node)
        if value is not None and 'layout_bgimage' not in already_processed:
            already_processed.add('layout_bgimage')
            self.layout_bgimage = value
        value = find_attr_value_('primary_video_source', node)
        if value is not None and 'primary_video_source' not in already_processed:
            already_processed.add('primary_video_source')
            self.primary_video_source = value
        value = find_attr_value_('gusid', node)
        if value is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            self.gusid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'conf_action':
            obj_ = conf_action.factory()
            obj_.build(child_)
            self.conf_action = obj_
            obj_.original_tagname_ = 'conf_action'
# end class conference


class conference_response(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, max_parties=None, reserve=None, layout=None, layout_regions=None, layout_size=None, orientation=None, aspect_ratio_mode=None, caption=None, caption_duration=None, beep='yes', clamp_dtmf=None, auto_gain_control=None, echo_cancellation=None, active_talker_region=None, active_talker_interval=None, max_active_talkers=None, region_overlays=None, layout_bgcolor=None, layout_bgimage=None, primary_video_source=None, gusid=None, href=None, identifier=None, appid=None, conf_action=None, conf_participant=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.max_parties = _cast(None, max_parties)
        self.reserve = _cast(None, reserve)
        self.layout = _cast(None, layout)
        self.layout_regions = _cast(None, layout_regions)
        self.layout_size = _cast(None, layout_size)
        self.orientation = _cast(None, orientation)
        self.aspect_ratio_mode = _cast(None, aspect_ratio_mode)
        self.caption = _cast(None, caption)
        self.caption_duration = _cast(None, caption_duration)
        self.beep = _cast(None, beep)
        self.clamp_dtmf = _cast(None, clamp_dtmf)
        self.auto_gain_control = _cast(None, auto_gain_control)
        self.echo_cancellation = _cast(None, echo_cancellation)
        self.active_talker_region = _cast(None, active_talker_region)
        self.active_talker_interval = _cast(None, active_talker_interval)
        self.max_active_talkers = _cast(None, max_active_talkers)
        self.region_overlays = _cast(None, region_overlays)
        self.layout_bgcolor = _cast(None, layout_bgcolor)
        self.layout_bgimage = _cast(None, layout_bgimage)
        self.primary_video_source = _cast(None, primary_video_source)
        self.gusid = _cast(None, gusid)
        self.href = _cast(None, href)
        self.identifier = _cast(None, identifier)
        self.appid = _cast(None, appid)
        self.conf_action = conf_action
        if conf_participant is None:
            self.conf_participant = []
        else:
            self.conf_participant = conf_participant
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, conference_response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if conference_response.subclass:
            return conference_response.subclass(*args_, **kwargs_)
        else:
            return conference_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_conf_action(self): return self.conf_action
    def set_conf_action(self, conf_action): self.conf_action = conf_action
    def get_conf_participant(self): return self.conf_participant
    def set_conf_participant(self, conf_participant): self.conf_participant = conf_participant
    def add_conf_participant(self, value): self.conf_participant.append(value)
    def insert_conf_participant_at(self, index, value): self.conf_participant.insert(index, value)
    def replace_conf_participant_at(self, index, value): self.conf_participant[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_max_parties(self): return self.max_parties
    def set_max_parties(self, max_parties): self.max_parties = max_parties
    def get_reserve(self): return self.reserve
    def set_reserve(self, reserve): self.reserve = reserve
    def get_layout(self): return self.layout
    def set_layout(self, layout): self.layout = layout
    def get_layout_regions(self): return self.layout_regions
    def set_layout_regions(self, layout_regions): self.layout_regions = layout_regions
    def get_layout_size(self): return self.layout_size
    def set_layout_size(self, layout_size): self.layout_size = layout_size
    def get_orientation(self): return self.orientation
    def set_orientation(self, orientation): self.orientation = orientation
    def get_aspect_ratio_mode(self): return self.aspect_ratio_mode
    def set_aspect_ratio_mode(self, aspect_ratio_mode): self.aspect_ratio_mode = aspect_ratio_mode
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_caption_duration(self): return self.caption_duration
    def set_caption_duration(self, caption_duration): self.caption_duration = caption_duration
    def get_beep(self): return self.beep
    def set_beep(self, beep): self.beep = beep
    def get_clamp_dtmf(self): return self.clamp_dtmf
    def set_clamp_dtmf(self, clamp_dtmf): self.clamp_dtmf = clamp_dtmf
    def get_auto_gain_control(self): return self.auto_gain_control
    def set_auto_gain_control(self, auto_gain_control): self.auto_gain_control = auto_gain_control
    def get_echo_cancellation(self): return self.echo_cancellation
    def set_echo_cancellation(self, echo_cancellation): self.echo_cancellation = echo_cancellation
    def get_active_talker_region(self): return self.active_talker_region
    def set_active_talker_region(self, active_talker_region): self.active_talker_region = active_talker_region
    def get_active_talker_interval(self): return self.active_talker_interval
    def set_active_talker_interval(self, active_talker_interval): self.active_talker_interval = active_talker_interval
    def get_max_active_talkers(self): return self.max_active_talkers
    def set_max_active_talkers(self, max_active_talkers): self.max_active_talkers = max_active_talkers
    def get_region_overlays(self): return self.region_overlays
    def set_region_overlays(self, region_overlays): self.region_overlays = region_overlays
    def get_layout_bgcolor(self): return self.layout_bgcolor
    def set_layout_bgcolor(self, layout_bgcolor): self.layout_bgcolor = layout_bgcolor
    def get_layout_bgimage(self): return self.layout_bgimage
    def set_layout_bgimage(self, layout_bgimage): self.layout_bgimage = layout_bgimage
    def get_primary_video_source(self): return self.primary_video_source
    def set_primary_video_source(self, primary_video_source): self.primary_video_source = primary_video_source
    def get_gusid(self): return self.gusid
    def set_gusid(self, gusid): self.gusid = gusid
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_appid(self): return self.appid
    def set_appid(self, appid): self.appid = appid
    def validate_media_type(self, value):
        # Validate type media_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['audio', 'video', 'audiovideo', 'message', 'image', 'unknown', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on media_type' % {"value" : value.encode("utf-8")} )
    def validate_layout_size_option(self, value):
        # Validate type layout_size_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['automatic', 'qcif', 'cif', 'vga', '720p']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on layout_size_option' % {"value" : value.encode("utf-8")} )
    def validate_orientation_option(self, value):
        # Validate type orientation_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['landscape', 'portrait']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on orientation_option' % {"value" : value.encode("utf-8")} )
    def validate_aspect_ratio_mode_option(self, value):
        # Validate type aspect_ratio_mode_option, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fill', 'fit', 'crop', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on aspect_ratio_mode_option' % {"value" : value.encode("utf-8")} )
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def validate_time_value(self, value):
        # Validate type time_value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_time_value_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_time_value_patterns_, ))
    validate_time_value_patterns_ = [['^(\\+)?([0-9]*\\.)?[0-9]+(ms$|^s)$|^infinite$']]
    def hasContent_(self):
        if (
            self.conf_action is not None or
            self.conf_participant
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conference_response', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('conference_response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conference_response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conference_response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conference_response'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.max_parties is not None and 'max_parties' not in already_processed:
            already_processed.add('max_parties')
            outfile.write(' max_parties=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.max_parties), input_name='max_parties')), ))
        if self.reserve is not None and 'reserve' not in already_processed:
            already_processed.add('reserve')
            outfile.write(' reserve=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reserve), input_name='reserve')), ))
        if self.layout is not None and 'layout' not in already_processed:
            already_processed.add('layout')
            outfile.write(' layout=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.layout), input_name='layout')), ))
        if self.layout_regions is not None and 'layout_regions' not in already_processed:
            already_processed.add('layout_regions')
            outfile.write(' layout_regions=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.layout_regions), input_name='layout_regions')), ))
        if self.layout_size is not None and 'layout_size' not in already_processed:
            already_processed.add('layout_size')
            outfile.write(' layout_size=%s' % (quote_attrib(self.layout_size), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (quote_attrib(self.orientation), ))
        if self.aspect_ratio_mode is not None and 'aspect_ratio_mode' not in already_processed:
            already_processed.add('aspect_ratio_mode')
            outfile.write(' aspect_ratio_mode=%s' % (quote_attrib(self.aspect_ratio_mode), ))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (quote_attrib(self.caption), ))
        if self.caption_duration is not None and 'caption_duration' not in already_processed:
            already_processed.add('caption_duration')
            outfile.write(' caption_duration=%s' % (quote_attrib(self.caption_duration), ))
        if self.beep != "yes" and 'beep' not in already_processed:
            already_processed.add('beep')
            outfile.write(' beep=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.beep), input_name='beep')), ))
        if self.clamp_dtmf is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            outfile.write(' clamp_dtmf=%s' % (quote_attrib(self.clamp_dtmf), ))
        if self.auto_gain_control is not None and 'auto_gain_control' not in already_processed:
            already_processed.add('auto_gain_control')
            outfile.write(' auto_gain_control=%s' % (quote_attrib(self.auto_gain_control), ))
        if self.echo_cancellation is not None and 'echo_cancellation' not in already_processed:
            already_processed.add('echo_cancellation')
            outfile.write(' echo_cancellation=%s' % (quote_attrib(self.echo_cancellation), ))
        if self.active_talker_region is not None and 'active_talker_region' not in already_processed:
            already_processed.add('active_talker_region')
            outfile.write(' active_talker_region=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.active_talker_region), input_name='active_talker_region')), ))
        if self.active_talker_interval is not None and 'active_talker_interval' not in already_processed:
            already_processed.add('active_talker_interval')
            outfile.write(' active_talker_interval=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.active_talker_interval), input_name='active_talker_interval')), ))
        if self.max_active_talkers is not None and 'max_active_talkers' not in already_processed:
            already_processed.add('max_active_talkers')
            outfile.write(' max_active_talkers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.max_active_talkers), input_name='max_active_talkers')), ))
        if self.region_overlays is not None and 'region_overlays' not in already_processed:
            already_processed.add('region_overlays')
            outfile.write(' region_overlays=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.region_overlays), input_name='region_overlays')), ))
        if self.layout_bgcolor is not None and 'layout_bgcolor' not in already_processed:
            already_processed.add('layout_bgcolor')
            outfile.write(' layout_bgcolor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.layout_bgcolor), input_name='layout_bgcolor')), ))
        if self.layout_bgimage is not None and 'layout_bgimage' not in already_processed:
            already_processed.add('layout_bgimage')
            outfile.write(' layout_bgimage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.layout_bgimage), input_name='layout_bgimage')), ))
        if self.primary_video_source is not None and 'primary_video_source' not in already_processed:
            already_processed.add('primary_video_source')
            outfile.write(' primary_video_source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.primary_video_source), input_name='primary_video_source')), ))
        if self.gusid is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            outfile.write(' gusid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gusid), input_name='gusid')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.identifier is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            outfile.write(' identifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.identifier), input_name='identifier')), ))
        if self.appid is not None and 'appid' not in already_processed:
            already_processed.add('appid')
            outfile.write(' appid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.appid), input_name='appid')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='conference_response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.conf_action is not None:
            self.conf_action.export(outfile, level, namespace_, name_='conf_action', pretty_print=pretty_print)
        for conf_participant_ in self.conf_participant:
            conf_participant_.export(outfile, level, namespace_, name_='conf_participant', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_media_type(self.type_)    # validate type media_type
        value = find_attr_value_('max_parties', node)
        if value is not None and 'max_parties' not in already_processed:
            already_processed.add('max_parties')
            self.max_parties = value
        value = find_attr_value_('reserve', node)
        if value is not None and 'reserve' not in already_processed:
            already_processed.add('reserve')
            self.reserve = value
        value = find_attr_value_('layout', node)
        if value is not None and 'layout' not in already_processed:
            already_processed.add('layout')
            self.layout = value
        value = find_attr_value_('layout_regions', node)
        if value is not None and 'layout_regions' not in already_processed:
            already_processed.add('layout_regions')
            self.layout_regions = value
        value = find_attr_value_('layout_size', node)
        if value is not None and 'layout_size' not in already_processed:
            already_processed.add('layout_size')
            self.layout_size = value
            self.validate_layout_size_option(self.layout_size)    # validate type layout_size_option
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_orientation_option(self.orientation)    # validate type orientation_option
        value = find_attr_value_('aspect_ratio_mode', node)
        if value is not None and 'aspect_ratio_mode' not in already_processed:
            already_processed.add('aspect_ratio_mode')
            self.aspect_ratio_mode = value
            self.validate_aspect_ratio_mode_option(self.aspect_ratio_mode)    # validate type aspect_ratio_mode_option
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
            self.validate_boolean_type(self.caption)    # validate type boolean_type
        value = find_attr_value_('caption_duration', node)
        if value is not None and 'caption_duration' not in already_processed:
            already_processed.add('caption_duration')
            self.caption_duration = value
            self.validate_time_value(self.caption_duration)    # validate type time_value
        value = find_attr_value_('beep', node)
        if value is not None and 'beep' not in already_processed:
            already_processed.add('beep')
            self.beep = value
        value = find_attr_value_('clamp_dtmf', node)
        if value is not None and 'clamp_dtmf' not in already_processed:
            already_processed.add('clamp_dtmf')
            self.clamp_dtmf = value
            self.validate_boolean_type(self.clamp_dtmf)    # validate type boolean_type
        value = find_attr_value_('auto_gain_control', node)
        if value is not None and 'auto_gain_control' not in already_processed:
            already_processed.add('auto_gain_control')
            self.auto_gain_control = value
            self.validate_boolean_type(self.auto_gain_control)    # validate type boolean_type
        value = find_attr_value_('echo_cancellation', node)
        if value is not None and 'echo_cancellation' not in already_processed:
            already_processed.add('echo_cancellation')
            self.echo_cancellation = value
            self.validate_boolean_type(self.echo_cancellation)    # validate type boolean_type
        value = find_attr_value_('active_talker_region', node)
        if value is not None and 'active_talker_region' not in already_processed:
            already_processed.add('active_talker_region')
            self.active_talker_region = value
        value = find_attr_value_('active_talker_interval', node)
        if value is not None and 'active_talker_interval' not in already_processed:
            already_processed.add('active_talker_interval')
            self.active_talker_interval = value
        value = find_attr_value_('max_active_talkers', node)
        if value is not None and 'max_active_talkers' not in already_processed:
            already_processed.add('max_active_talkers')
            self.max_active_talkers = value
        value = find_attr_value_('region_overlays', node)
        if value is not None and 'region_overlays' not in already_processed:
            already_processed.add('region_overlays')
            self.region_overlays = value
        value = find_attr_value_('layout_bgcolor', node)
        if value is not None and 'layout_bgcolor' not in already_processed:
            already_processed.add('layout_bgcolor')
            self.layout_bgcolor = value
        value = find_attr_value_('layout_bgimage', node)
        if value is not None and 'layout_bgimage' not in already_processed:
            already_processed.add('layout_bgimage')
            self.layout_bgimage = value
        value = find_attr_value_('primary_video_source', node)
        if value is not None and 'primary_video_source' not in already_processed:
            already_processed.add('primary_video_source')
            self.primary_video_source = value
        value = find_attr_value_('gusid', node)
        if value is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            self.gusid = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('identifier', node)
        if value is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            self.identifier = value
        value = find_attr_value_('appid', node)
        if value is not None and 'appid' not in already_processed:
            already_processed.add('appid')
            self.appid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'conf_action':
            obj_ = conf_action.factory()
            obj_.build(child_)
            self.conf_action = obj_
            obj_.original_tagname_ = 'conf_action'
        elif nodeName_ == 'conf_participant':
            obj_ = conf_participant.factory()
            obj_.build(child_)
            self.conf_participant.append(obj_)
            obj_.original_tagname_ = 'conf_participant'
# end class conference_response


class conferences_response(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, size=None, conference_response=None):
        self.original_tagname_ = None
        self.size = _cast(None, size)
        if conference_response is None:
            self.conference_response = []
        else:
            self.conference_response = conference_response
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, conferences_response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if conferences_response.subclass:
            return conferences_response.subclass(*args_, **kwargs_)
        else:
            return conferences_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_conference_response(self): return self.conference_response
    def set_conference_response(self, conference_response): self.conference_response = conference_response
    def add_conference_response(self, value): self.conference_response.append(value)
    def insert_conference_response_at(self, index, value): self.conference_response.insert(index, value)
    def replace_conference_response_at(self, index, value): self.conference_response[index] = value
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.conference_response
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conferences_response', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('conferences_response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conferences_response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conferences_response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conferences_response'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='conferences_response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for conference_response_ in self.conference_response:
            conference_response_.export(outfile, level, namespace_, name_='conference_response', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'conference_response':
            obj_ = conference_response.factory()
            obj_.build(child_)
            self.conference_response.append(obj_)
            obj_.original_tagname_ = 'conference_response'
# end class conferences_response


class mrcp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, asr='yes', tts='yes', gusid=None, mrcp_action=None):
        self.original_tagname_ = None
        self.asr = _cast(None, asr)
        self.tts = _cast(None, tts)
        self.gusid = _cast(None, gusid)
        self.mrcp_action = mrcp_action
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mrcp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mrcp.subclass:
            return mrcp.subclass(*args_, **kwargs_)
        else:
            return mrcp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mrcp_action(self): return self.mrcp_action
    def set_mrcp_action(self, mrcp_action): self.mrcp_action = mrcp_action
    def get_asr(self): return self.asr
    def set_asr(self, asr): self.asr = asr
    def get_tts(self): return self.tts
    def set_tts(self, tts): self.tts = tts
    def get_gusid(self): return self.gusid
    def set_gusid(self, gusid): self.gusid = gusid
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.mrcp_action is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mrcp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mrcp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mrcp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mrcp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mrcp'):
        if self.asr != "yes" and 'asr' not in already_processed:
            already_processed.add('asr')
            outfile.write(' asr=%s' % (quote_attrib(self.asr), ))
        if self.tts != "yes" and 'tts' not in already_processed:
            already_processed.add('tts')
            outfile.write(' tts=%s' % (quote_attrib(self.tts), ))
        if self.gusid is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            outfile.write(' gusid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gusid), input_name='gusid')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mrcp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mrcp_action is not None:
            self.mrcp_action.export(outfile, level, namespace_, name_='mrcp_action', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('asr', node)
        if value is not None and 'asr' not in already_processed:
            already_processed.add('asr')
            self.asr = value
            self.validate_boolean_type(self.asr)    # validate type boolean_type
        value = find_attr_value_('tts', node)
        if value is not None and 'tts' not in already_processed:
            already_processed.add('tts')
            self.tts = value
            self.validate_boolean_type(self.tts)    # validate type boolean_type
        value = find_attr_value_('gusid', node)
        if value is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            self.gusid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mrcp_action':
            obj_ = mrcp_action.factory()
            obj_.build(child_)
            self.mrcp_action = obj_
            obj_.original_tagname_ = 'mrcp_action'
# end class mrcp


class mrcp_response(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, asr=None, tts=None, gusid=None, href=None, identifier=None, appid=None, mrcp_action=None):
        self.original_tagname_ = None
        self.asr = _cast(None, asr)
        self.tts = _cast(None, tts)
        self.gusid = _cast(None, gusid)
        self.href = _cast(None, href)
        self.identifier = _cast(None, identifier)
        self.appid = _cast(None, appid)
        self.mrcp_action = mrcp_action
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mrcp_response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mrcp_response.subclass:
            return mrcp_response.subclass(*args_, **kwargs_)
        else:
            return mrcp_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mrcp_action(self): return self.mrcp_action
    def set_mrcp_action(self, mrcp_action): self.mrcp_action = mrcp_action
    def get_asr(self): return self.asr
    def set_asr(self, asr): self.asr = asr
    def get_tts(self): return self.tts
    def set_tts(self, tts): self.tts = tts
    def get_gusid(self): return self.gusid
    def set_gusid(self, gusid): self.gusid = gusid
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_appid(self): return self.appid
    def set_appid(self, appid): self.appid = appid
    def validate_boolean_type(self, value):
        # Validate type boolean_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on boolean_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.mrcp_action is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mrcp_response', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mrcp_response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mrcp_response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mrcp_response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mrcp_response'):
        if self.asr is not None and 'asr' not in already_processed:
            already_processed.add('asr')
            outfile.write(' asr=%s' % (quote_attrib(self.asr), ))
        if self.tts is not None and 'tts' not in already_processed:
            already_processed.add('tts')
            outfile.write(' tts=%s' % (quote_attrib(self.tts), ))
        if self.gusid is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            outfile.write(' gusid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gusid), input_name='gusid')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.identifier is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            outfile.write(' identifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.identifier), input_name='identifier')), ))
        if self.appid is not None and 'appid' not in already_processed:
            already_processed.add('appid')
            outfile.write(' appid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.appid), input_name='appid')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mrcp_response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mrcp_action is not None:
            self.mrcp_action.export(outfile, level, namespace_, name_='mrcp_action', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('asr', node)
        if value is not None and 'asr' not in already_processed:
            already_processed.add('asr')
            self.asr = value
            self.validate_boolean_type(self.asr)    # validate type boolean_type
        value = find_attr_value_('tts', node)
        if value is not None and 'tts' not in already_processed:
            already_processed.add('tts')
            self.tts = value
            self.validate_boolean_type(self.tts)    # validate type boolean_type
        value = find_attr_value_('gusid', node)
        if value is not None and 'gusid' not in already_processed:
            already_processed.add('gusid')
            self.gusid = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('identifier', node)
        if value is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            self.identifier = value
        value = find_attr_value_('appid', node)
        if value is not None and 'appid' not in already_processed:
            already_processed.add('appid')
            self.appid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mrcp_action':
            obj_ = mrcp_action.factory()
            obj_.build(child_)
            self.mrcp_action = obj_
            obj_.original_tagname_ = 'mrcp_action'
# end class mrcp_response


class mrcps_response(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, size=None, mrcp_response=None):
        self.original_tagname_ = None
        self.size = _cast(None, size)
        if mrcp_response is None:
            self.mrcp_response = []
        else:
            self.mrcp_response = mrcp_response
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mrcps_response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mrcps_response.subclass:
            return mrcps_response.subclass(*args_, **kwargs_)
        else:
            return mrcps_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mrcp_response(self): return self.mrcp_response
    def set_mrcp_response(self, mrcp_response): self.mrcp_response = mrcp_response
    def add_mrcp_response(self, value): self.mrcp_response.append(value)
    def insert_mrcp_response_at(self, index, value): self.mrcp_response.insert(index, value)
    def replace_mrcp_response_at(self, index, value): self.mrcp_response[index] = value
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.mrcp_response
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mrcps_response', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mrcps_response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mrcps_response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mrcps_response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mrcps_response'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mrcps_response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mrcp_response_ in self.mrcp_response:
            mrcp_response_.export(outfile, level, namespace_, name_='mrcp_response', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mrcp_response':
            obj_ = mrcp_response.factory()
            obj_.build(child_)
            self.mrcp_response.append(obj_)
            obj_.original_tagname_ = 'mrcp_response'
# end class mrcps_response


class web_service(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, call=None, call_response=None, calls_response=None, conference=None, conference_response=None, conferences_response=None, eventhandler=None, eventhandler_response=None, eventhandlers_response=None, mrcp=None, mrcp_response=None, mrcps_response=None, event=None, error=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        self.call = call
        self.call_response = call_response
        self.calls_response = calls_response
        self.conference = conference
        self.conference_response = conference_response
        self.conferences_response = conferences_response
        self.eventhandler = eventhandler
        self.eventhandler_response = eventhandler_response
        self.eventhandlers_response = eventhandlers_response
        self.mrcp = mrcp
        self.mrcp_response = mrcp_response
        self.mrcps_response = mrcps_response
        self.event = event
        self.error = error
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, web_service)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if web_service.subclass:
            return web_service.subclass(*args_, **kwargs_)
        else:
            return web_service(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_call(self): return self.call
    def set_call(self, call): self.call = call
    def get_call_response(self): return self.call_response
    def set_call_response(self, call_response): self.call_response = call_response
    def get_calls_response(self): return self.calls_response
    def set_calls_response(self, calls_response): self.calls_response = calls_response
    def get_conference(self): return self.conference
    def set_conference(self, conference): self.conference = conference
    def get_conference_response(self): return self.conference_response
    def set_conference_response(self, conference_response): self.conference_response = conference_response
    def get_conferences_response(self): return self.conferences_response
    def set_conferences_response(self, conferences_response): self.conferences_response = conferences_response
    def get_eventhandler(self): return self.eventhandler
    def set_eventhandler(self, eventhandler): self.eventhandler = eventhandler
    def get_eventhandler_response(self): return self.eventhandler_response
    def set_eventhandler_response(self, eventhandler_response): self.eventhandler_response = eventhandler_response
    def get_eventhandlers_response(self): return self.eventhandlers_response
    def set_eventhandlers_response(self, eventhandlers_response): self.eventhandlers_response = eventhandlers_response
    def get_mrcp(self): return self.mrcp
    def set_mrcp(self, mrcp): self.mrcp = mrcp
    def get_mrcp_response(self): return self.mrcp_response
    def set_mrcp_response(self, mrcp_response): self.mrcp_response = mrcp_response
    def get_mrcps_response(self): return self.mrcps_response
    def set_mrcps_response(self, mrcps_response): self.mrcps_response = mrcps_response
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def get_error(self): return self.error
    def set_error(self, error): self.error = error
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.call is not None or
            self.call_response is not None or
            self.calls_response is not None or
            self.conference is not None or
            self.conference_response is not None or
            self.conferences_response is not None or
            self.eventhandler is not None or
            self.eventhandler_response is not None or
            self.eventhandlers_response is not None or
            self.mrcp is not None or
            self.mrcp_response is not None or
            self.mrcps_response is not None or
            self.event is not None or
            self.error is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='web_service', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('web_service')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='web_service')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='web_service', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='web_service'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='web_service', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.call is not None:
            self.call.export(outfile, level, namespace_, name_='call', pretty_print=pretty_print)
        if self.call_response is not None:
            self.call_response.export(outfile, level, namespace_, name_='call_response', pretty_print=pretty_print)
        if self.calls_response is not None:
            self.calls_response.export(outfile, level, namespace_, name_='calls_response', pretty_print=pretty_print)
        if self.conference is not None:
            self.conference.export(outfile, level, namespace_, name_='conference', pretty_print=pretty_print)
        if self.conference_response is not None:
            self.conference_response.export(outfile, level, namespace_, name_='conference_response', pretty_print=pretty_print)
        if self.conferences_response is not None:
            self.conferences_response.export(outfile, level, namespace_, name_='conferences_response', pretty_print=pretty_print)
        if self.eventhandler is not None:
            self.eventhandler.export(outfile, level, namespace_, name_='eventhandler', pretty_print=pretty_print)
        if self.eventhandler_response is not None:
            self.eventhandler_response.export(outfile, level, namespace_, name_='eventhandler_response', pretty_print=pretty_print)
        if self.eventhandlers_response is not None:
            self.eventhandlers_response.export(outfile, level, namespace_, name_='eventhandlers_response', pretty_print=pretty_print)
        if self.mrcp is not None:
            self.mrcp.export(outfile, level, namespace_, name_='mrcp', pretty_print=pretty_print)
        if self.mrcp_response is not None:
            self.mrcp_response.export(outfile, level, namespace_, name_='mrcp_response', pretty_print=pretty_print)
        if self.mrcps_response is not None:
            self.mrcps_response.export(outfile, level, namespace_, name_='mrcps_response', pretty_print=pretty_print)
        if self.event is not None:
            self.event.export(outfile, level, namespace_, name_='event', pretty_print=pretty_print)
        if self.error is not None:
            self.error.export(outfile, level, namespace_, name_='error', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'call':
            obj_ = call.factory()
            obj_.build(child_)
            self.call = obj_
            obj_.original_tagname_ = 'call'
        elif nodeName_ == 'call_response':
            obj_ = call_response.factory()
            obj_.build(child_)
            self.call_response = obj_
            obj_.original_tagname_ = 'call_response'
        elif nodeName_ == 'calls_response':
            obj_ = calls_response.factory()
            obj_.build(child_)
            self.calls_response = obj_
            obj_.original_tagname_ = 'calls_response'
        elif nodeName_ == 'conference':
            obj_ = conference.factory()
            obj_.build(child_)
            self.conference = obj_
            obj_.original_tagname_ = 'conference'
        elif nodeName_ == 'conference_response':
            obj_ = conference_response.factory()
            obj_.build(child_)
            self.conference_response = obj_
            obj_.original_tagname_ = 'conference_response'
        elif nodeName_ == 'conferences_response':
            obj_ = conferences_response.factory()
            obj_.build(child_)
            self.conferences_response = obj_
            obj_.original_tagname_ = 'conferences_response'
        elif nodeName_ == 'eventhandler':
            obj_ = eventhandler.factory()
            obj_.build(child_)
            self.eventhandler = obj_
            obj_.original_tagname_ = 'eventhandler'
        elif nodeName_ == 'eventhandler_response':
            obj_ = eventhandler_response.factory()
            obj_.build(child_)
            self.eventhandler_response = obj_
            obj_.original_tagname_ = 'eventhandler_response'
        elif nodeName_ == 'eventhandlers_response':
            obj_ = eventhandlers_response.factory()
            obj_.build(child_)
            self.eventhandlers_response = obj_
            obj_.original_tagname_ = 'eventhandlers_response'
        elif nodeName_ == 'mrcp':
            obj_ = mrcp.factory()
            obj_.build(child_)
            self.mrcp = obj_
            obj_.original_tagname_ = 'mrcp'
        elif nodeName_ == 'mrcp_response':
            obj_ = mrcp_response.factory()
            obj_.build(child_)
            self.mrcp_response = obj_
            obj_.original_tagname_ = 'mrcp_response'
        elif nodeName_ == 'mrcps_response':
            obj_ = mrcps_response.factory()
            obj_.build(child_)
            self.mrcps_response = obj_
            obj_.original_tagname_ = 'mrcps_response'
        elif nodeName_ == 'event':
            obj_ = event.factory()
            obj_.build(child_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'error':
            obj_ = error.factory()
            obj_.build(child_)
            self.error = obj_
            obj_.original_tagname_ = 'error'
# end class web_service


class msg_payload_contentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, content=None):
        self.original_tagname_ = None
        self.content = _cast(None, content)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, msg_payload_contentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if msg_payload_contentType.subclass:
            return msg_payload_contentType.subclass(*args_, **kwargs_)
        else:
            return msg_payload_contentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='msg_payload_contentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('msg_payload_contentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='msg_payload_contentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='msg_payload_contentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='msg_payload_contentType'):
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.content), input_name='content')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='msg_payload_contentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class msg_payload_contentType


class msg_payload_uriType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uri=None):
        self.original_tagname_ = None
        self.uri = _cast(None, uri)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, msg_payload_uriType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if msg_payload_uriType.subclass:
            return msg_payload_uriType.subclass(*args_, **kwargs_)
        else:
            return msg_payload_uriType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='msg_payload_uriType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('msg_payload_uriType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='msg_payload_uriType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='msg_payload_uriType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='msg_payload_uriType'):
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='msg_payload_uriType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class msg_payload_uriType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'dvr_setting'
        rootClass = dvr_setting
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'dvr_setting'
        rootClass = dvr_setting
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'dvr_setting'
        rootClass = dvr_setting
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'dvr_setting'
        rootClass = dvr_setting
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from xmsrest import *\n\n')
        sys.stdout.write('import xmsrest as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "add_ice_candidate",
    "add_party",
    "call",
    "call_action",
    "call_response",
    "calls_response",
    "conf_action",
    "conf_participant",
    "conference",
    "conference_response",
    "conferences_response",
    "content_element",
    "cpa_operation",
    "define_grammar",
    "dial",
    "dvr_setting",
    "error",
    "event",
    "event_data",
    "eventhandler",
    "eventhandler_response",
    "eventhandlers_response",
    "eventsubscribe",
    "get_asr_param",
    "get_call_info",
    "get_last_action",
    "get_last_event",
    "get_tts_param",
    "hangup",
    "join",
    "mrcp",
    "mrcp_action",
    "mrcp_response",
    "mrcp_update_action",
    "mrcps_response",
    "msg_payload",
    "msg_payload_contentType",
    "msg_payload_uriType",
    "multi_record",
    "overlay",
    "param",
    "play",
    "play_source",
    "playcollect",
    "playrecord",
    "recognize",
    "record",
    "record_track",
    "recording_audio_mime_params",
    "recording_video_mime_params",
    "redirect",
    "remove_party",
    "send_answer_ack",
    "send_dtmf",
    "send_event",
    "send_hangup_ack",
    "send_info",
    "send_info_ack",
    "send_message",
    "send_prack",
    "send_prack_ack",
    "set_asr_param",
    "set_tts_param",
    "sip_headers",
    "speak",
    "stop",
    "transfer",
    "unjoin",
    "update_multi_record",
    "update_party",
    "update_play",
    "web_service"
]
